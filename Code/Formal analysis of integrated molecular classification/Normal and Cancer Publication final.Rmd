---
title: "Normal and Cancer Publication final"
author: "Daniel Skubleny"
date: '2023-03-05'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


#RUV cancer/normal together FFPE
```{r}
#***** Reading Nanostring gene expression raw data
Nano_ExpressionMatrix <- read.delim("~/Documents/PhD/Results: spreadsheets/Chapter 5/Nanostring/run1-7.txt",
                                    stringsAsFactors = FALSE, header = TRUE, as.is = TRUE)

#***** Reading sample and clinical information
Nano_SampleInfo <- read.delim("~/Documents/PhD/Results: spreadsheets/Chapter 5/Nanostring/nanostring_samples.txt",
                              stringsAsFactors = FALSE, header = TRUE, as.is = TRUE)
Nano_SampleInfo = Nano_SampleInfo[c(1:84),]

dim(Nano_SampleInfo) # 24 12
table(Nano_SampleInfo$Tissues)

#Exclude poor samples
exclude = Nano_SampleInfo$exclude=="TRUE" 
Nano_SampleInfo = Nano_SampleInfo[!(Nano_SampleInfo$exclude=="TRUE"),] 
Nano_SampleInfo = dplyr::select(Nano_SampleInfo, -"exclusion_reason")


Nano_RawCounts = dplyr::filter(Nano_ExpressionMatrix,subtype=="TCGA"| subtype=="TME"  | subtype=="Negative" | subtype=="Positive"| subtype=="Housekeeping")

#***** Expression matrix
Nano_RawCounts <- as.matrix(Nano_RawCounts[ , 5:ncol(Nano_RawCounts)])
exclude = colnames(Nano_RawCounts[,exclude])
Nano_RawCounts = Nano_RawCounts[ , !(colnames(Nano_RawCounts) %in% exclude)]



#Exclude organoids OR FFPE OR Cancer OR normal
exclude = Nano_SampleInfo$sample_type=="organoid"
exclude = colnames(Nano_RawCounts[,exclude])
Nano_RawCounts = Nano_RawCounts[ , !(colnames(Nano_RawCounts) %in% exclude)]
Nano_SampleInfo = Nano_SampleInfo[!(Nano_SampleInfo$sample_type=="organoid"),] 

row.names(Nano_RawCounts) <- Nano_ExpressionMatrix[Nano_ExpressionMatrix$subtype=="TCGA" | Nano_ExpressionMatrix$subtype=="TME" | Nano_ExpressionMatrix$subtype=="Negative" |Nano_ExpressionMatrix$subtype=="Positive" |Nano_ExpressionMatrix$subtype=="Housekeeping" ,]$Probe.Name
Nano_SampleInfo$SampleNames <- colnames(Nano_RawCounts)


##################################################################################################################################
##################################################################  Exploratory  data analysis – raw counts #####################
#***** Colors for each cartridges
Color_Batches <- c('purple','orange','darkred','blue','chartreuse',
                   'darkgoldenrod4','tan2','darkgreen','red3','darkmagenta',
                   'deeppink','violet','navy','red','dodgerblue')

#***** box plot of raw data - Endogenous genes only
RawCounts_log <- log2(Nano_RawCounts[1:107 , ]+1) # Excluding 7 housekeeping genes and Nanostring spike-ins
par(mar = c(6.5,6.5,2.3,0), mgp = c(3.7 , 1 , 0))
boxplot(RawCounts_log, las = 1, cex.axis = 2, ylab = '' , xlab = '', cex.lab = 4,
        xaxt = 'n', yaxt = 'n', main = 'Unnormalized counts', cex.main = 3.5,
        outline = FALSE, names = FALSE, frame = FALSE,
        whisklty = 3, whisklwd = 1.5, staplelty = 1, notch = TRUE, boxlwd = 2,
        staplelwd = 0 , boxcol = Color_Batches[factor(Nano_SampleInfo$Cartridges)],
        border = Color_Batches[factor(Nano_SampleInfo$cartridge)] , col='gray87')
box(lwd = 7, bty = 'l')
axis(1, cex.axis=1, at = c(1, seq(20,166,20)), cex.axis = 2.5, lwd.ticks = 4, mgp = c(3.5,1.6,0))
axis(2, at = c(0, seq(3,15,3)), mgp = c(3.5,.9,0), lwd.ticks = 4, las = 1, cex.axis=3)
mtext(expression(paste('Samples', '(', 'n'[samples], '=', '162', ')')), 1, line = 4.5, cex = 2.5)
mtext(expression(paste(Log[2],' (raw counts)')), 2, line = 3.5, cex = 2.7)


#***** RLE plot - Figure 1 A - Unormalized
par(mar = c(6.5,6.5,2.3,0))
boxplot(RawCounts_log - rowMedians(RawCounts_log),
        main = '', xlab = '', ylab = '', xaxt = 'n', yaxt = 'n', ylim = c(-4.1,4.1),
        outline = FALSE, names = FALSE, frame = FALSE, whisklty = 3, whisklwd = 1.5, staplelty = 1, notch = TRUE, boxlwd = 2,
        staplelwd = 0 , boxcol = Color_Batches[factor(Nano_SampleInfo$cartridge)],
        border = Color_Batches[factor(Nano_SampleInfo$cartridge)], col = 'gray87')
box(lwd = 7, bty = 'l')
title('Unnormalized counts', line = -2, cex.main = 3.5)
Median_RawData <- apply(RawCounts_log - rowMedians(RawCounts_log), 2, median)
points(c(1:ncol(RawCounts_log)), Median_RawData, col = Color_Batches[factor(Nano_SampleInfo$cartridge)], pch = 19, cex = 1.2)
axis(2, mgp = c(3.5, .9 ,0), lwd.ticks=6, las=1, cex.axis=3)
mtext('RLE', 2, line = 3.5, cex = 3.5)
abline(h = 0, col = 'black', lwd = 5, lty = 2)
par(lwd = 3)
legend(160, 4.1, legend = c(1,2,3,'.','.','.', 13,14,15),
       col = c(Color_Batches[1:3], rep('white', 3), Color_Batches[13:15]),
       pch = 19, bty = 'n', cex = 1.4)
text(x = 162, y = 4.2 ,labels  = 'Cartridges', cex = 1.5)
rm(Median_RawData)


#***** Average plot
### Average of Nanostring positive spike-ins controls
Mean_NegativeControlProbes <- apply(Nano_RawCounts[115:122, ], 2, mean)
### Average of Nanostring positive spike-ins controls
Mean_PositiveControlProbes <- apply(Nano_RawCounts[123:128, ], 2, mean)
### Average of housekeeping genes
Mean_HousekeepingGenes <- apply(Nano_RawCounts[108:114, ], 2, mean)
### Library size
LibrarySize <- colSums(Nano_RawCounts [ 1:128, ])

#### Average plots -  Supplementary Figure 2
par(mar = c(6,7,0,0))
plot(log2(LibrarySize), ylim = c(0,22), bty = 'l', typ = 'n', ylab = '', xlab = '', xaxt = 'n', yaxt = 'n')
axis(1, cex.axis = 1, at = c(1, seq(20,166,20)), cex.axis = 2, lwd.ticks = 4, mgp = c(3.5,1.4,0))
axis(2, cex.axis = 1, cex.axis = 2, lwd.ticks = 4, mgp = c(3.5,1,0), las = 1)
mtext(expression(paste(Log [2], ' (raw counts)')), 2, line = 3.5, cex = 3)
mtext(expression(paste('Samples', ' (', 'n'[samples], '=', '21', ')')), 1, line = 4.5, cex = 2.5)
X <- c(0,6,18,30,42,53,65,77,89,101,113,125,137,143,155,167)
GradiantColors <- paste0('gray', seq(90,20, by = -5))
for(i in 1:15) rect(X[i],-5, X[i+1], 22, col = GradiantColors[i], lty = 0 )
points(log2(LibrarySize), col = alpha('darkgoldenrod1', .8), pch = 15, cex = 1.8, lwd = 1.5)
lines(smooth.spline(c(1:length(LibrarySize)), log2(LibrarySize), df = 5), col = 'darkgoldenrod1', lwd = 4)
points(log2(Mean_HousekeepingGenes) + 3, cex = 2, col = alpha('red', .6), pch = 19)
lines(smooth.spline(c(1:length(LibrarySize)), log2(Mean_HousekeepingGenes) + 3, df = 5), col = 'red', lwd = 4)
points(log2(Mean_PositiveControlProbes) - 1, col = alpha('cyan2', .8), pch = 18, cex = 2.5)
lines(smooth.spline(c(1:length(LibrarySize)), log2(Mean_PositiveControlProbes) - 1, df = 5), col = 'cyan1', lwd = 4)
points(log2(Mean_NegativeControlProbes), col = alpha('green2', .6), pch = 17, cex = 1.8)
lines(smooth.spline(c(1:length(LibrarySize)), log2(Mean_NegativeControlProbes), df = 5), col = 'green2', lwd = 4)
box(lwd = 5, bty = 'l')
rm(X, GradiantColors, Mean_NegativeControlProbes,
   Mean_PositiveControlProbes, Mean_HousekeepingGenes,
   LibrarySize)


#***** Log ratio between all pairs of duplicated samples
DuplicatedSamples <- tuplicate(Nano_SampleInfo$Patient.barcodes, 2)
length(DuplicatedSamples) 

LogRatio_TechRep_RawCounts <- vector()
for(i in 1:1){
  index <- Nano_SampleInfo$Patient.barcodes == DuplicatedSamples[i]
  RepData <- RawCounts_log [ , index]
  LogRatio <- as.data.frame(RepData[ , 1] - RepData[ , 2] )
  colnames(LogRatio) <- 'LogRatio'
  LogRatio$Replicates <- rep( i , 107)
  LogRatio_TechRep_RawCounts <- rbind(LogRatio_TechRep_RawCounts , LogRatio)
  rm(i, index, RepData, LogRatio)
}
nrow(LogRatio_TechRep_RawCounts)/107 # 17
LogRatio_TechRep_RawCounts$Datasets <- 'Unnormalized'




##################################################################################################################################
############################################### RUV-III normalization - using technical replicates and control genes #############

#***** Creating replicate matrix
length(Nano_SampleInfo$Patient.barcodes) # 162
length(unique(Nano_SampleInfo$Patient.barcodes)) # 135

ReplicateMatrix <- ruv::replicate.matrix(Nano_SampleInfo$Patient.barcodes)
dim(ReplicateMatrix) # 162 133

### Making sure that every row has got only one number
par(mfrow = c(2,1))
barplot(colSums(ReplicateMatrix))
barplot(rowSums(ReplicateMatrix))
par(mfrow = c(1,1))


#***** Finding control genes
### Step 1: Using all genes as a set of negative control genes
# Performing RUVIII
dataRUV <- t(log2(Nano_RawCounts[1:107, ] + 1))
RUVcorrected <- ruv::RUVIII(Y = dataRUV, M = ReplicateMatrix, ctl = c(1:107))
RUVcorrected <- t(RUVcorrected)

### Step 2: Selecting the most stable genes from step 1
LowVarGenes <- apply(RUVcorrected, 1, var)
ControlGenes <- which(LowVarGenes < .5)
length(ControlGenes) # 15 genes


### Step3: Performing RUV-III using the ControlGenes set
RUVcorrected <- RUVIII(Y = dataRUV, M = ReplicateMatrix, ctl = ControlGenes, k = 7)
RUVcorrected <- t(RUVcorrected)
dim(RUVcorrected)
# We tried different numbers of k based on our positive controls####
all(colnames(RUVcorrected) == Nano_SampleInfo$SampleNames) ## TRUE


#***** RLE plots - Figure 1 A, RUV-III normalization
par(mar = c(6.5,6.5,2.3,0))
boxplot(RUVcorrected - rowMedians(RUVcorrected), main = '', xlab = '', ylab = '', xaxt = 'n', yaxt = 'n', ylim = c(-4.1,4.1),
        outline = FALSE, names = FALSE, frame = FALSE, whisklty = 3, whisklwd = 1.5, staplelty = 1, notch = TRUE, boxlwd = 2,
        staplelwd = 0 , boxcol = Color_Batches[factor(Nano_SampleInfo$cartridge)],
        border = Color_Batches[factor(Nano_SampleInfo$cartridge)], col = 'gray87')
box(lwd = 7, bty = 'l')
title('RUV-III normalized', line = -2, cex.main = 3.5)
Median_RUV <- apply(RUVcorrected - rowMedians(RUVcorrected), 2, median)
points(c(1:ncol(RUVcorrected)), Median_RUV, col = Color_Batches[factor(Nano_SampleInfo$cartridge)], pch = 19, cex = 1.2)
axis(1, cex.axis = 1, at = c(1, seq(20,166,20)), cex.axis = 2.5, lwd.ticks = 6,  mgp = c(3.5,1.6,0))
axis(2, mgp = c(3.5,.9,0), lwd.ticks = 6, las = 1, cex.axis = 3)
mtext(expression(paste('Samples','(', 'n'[samples], '=', '162', ')')),1 ,line = 5, cex = 3)
mtext('RLE', 2, line = 3.5, cex = 3.5)
abline(h = 0, col = 'black', lwd = 5, lty = 2)


#***** Correlation between ERCC1 and RRM1 in cancer samples
RUVIII_CancerData <- RUVcorrected[ , Nano_SampleInfo$Tissues=="cancer"]
dim(RUVIII_CancerData) ## 587 150
BioCo_RUV <- cor.test(unlist(t(RUVIII_CancerData['SMAD9' , ])) , unlist(t(RUVIII_CancerData[ 'JAK2' , ])), method = "spearman")[[4]]
par(mar = c(5,5,2,1))
plot (RUVIII_CancerData[ "SMAD9", ], RUVIII_CancerData [ "JAK2" , ],
      las = 1, pch = 21, col = "cyan", bg = 'blue', lwd = 1.2,
      main = "RUV-III normalized", bty = "l", cex.main = 2, mgp = c(3.2,.8,0),
      cex.axis = 1.7, cex.lab = 1.5, cex = 2.5, lwd.ticks = 3, ylab = "" ,
      xlab = expression(paste(italic(RRM1) , " (", log[2] , " normalized counts" , ")")))
mtext(expression(paste(italic(ERCC1) , " (", log[2] , " normalized counts" , ")")), 2, line = 3, cex = 1.5)
title(paste('(r = ', round(BioCo_RUV, digits = 2), ')'), line = -.5, cex = 1.4)
box(lwd = 6, bty = "l")


#***** Log DIFFERENCE between technical duplicated - per the paper
### Assessing the perfromance of RUV-III using 'leave out one duplicate'
DuplicatedSamples <- tuplicate(Nano_SampleInfo$Patient.barcodes, 2)
length(DuplicatedSamples) # 17
LogRatio_TechRep_RUVIII <- vector()
dataRUV <- t(log2(Nano_RawCounts[1:107, ] +1))

for(l in 1:length(DuplicatedSamples)){
  index <- Nano_SampleInfo$Patient.barcodes == DuplicatedSamples[l]
  info <- Nano_SampleInfo
  info$Patient.barcodes[index] <- c('Rep1', 'Rep2')
  X <- length(info$Patient.barcodes)
  Y <- length(unique(info$Patient.barcodes))
  
  ReplicateMatrix <- matrix(0, nrow = X, ncol = Y)
  row.names(ReplicateMatrix) <- info$Patient.barcodes
  colnames(ReplicateMatrix) <- unique(info$Patient.barcodes)
  for(i in 1:Y){
    n <- colnames(ReplicateMatrix)[i]
    sa <- which(row.names(ReplicateMatrix)==n)
    for(j in 1:length(sa)){
      ReplicateMatrix [sa[j] , i] <- 1
    }
  }
  RUVcorrected_Data <- ruv::RUVIII(dataRUV , ReplicateMatrix , ctl = ControlGenes, k = 2)
  RUVcorrected_Data <- t(RUVcorrected_Data)
  index <- which(index)
  LogRatio <- as.data.frame( (RUVcorrected_Data[ , index[1]] ) - (RUVcorrected_Data[ , index[2]]) )
  colnames(LogRatio) <- 'LogRatio'
  LogRatio$Replicates <- rep(l , 107)
  LogRatio_TechRep_RUVIII <- rbind(LogRatio_TechRep_RUVIII , LogRatio)
  rm(i, index, info, X, Y, LogRatio)
  
}
nrow(LogRatio_TechRep_RUVIII)/107
LogRatio_TechRep_RUVIII$Datasets <- 'RUV-III normalized'


#***** Technical Replicate Agreement plot for unnormalized, Nanostring Normalization and RUV-III (leave out one technical replicate)
### Figure 1 B
TRAallNormalizations <- rbind(LogRatio_TechRep_RawCounts, LogRatio_TechRep_RUVIII)
TRAallNormalizations$Replicates <- as.factor(TRAallNormalizations$Replicates)
TRAallNormalizations$Datasets <- as.factor(TRAallNormalizations$Datasets)
TRAallNormalizations$Datasets  <- factor(TRAallNormalizations$Datasets , levels = c('Unnormalized','RUV-III normalized'))
ggplot(data = TRAallNormalizations) +
  geom_boxplot(aes(y = LogRatio, x = Replicates, fill = Datasets, color=Datasets), outlier.size = .5,
               position = position_dodge(width = .7),
               width = 1, alpha = 0.8, lwd = .7) +
  ylab('Log ratio')+ylim(c(-10,10)) +
  scale_color_manual(values = c('lightblue', 'royalblue', 'navy')) +
  scale_fill_manual(values = c('lightblue', 'royalblue', 'navy')) +
  theme_classic() +
  geom_hline(yintercept = 0, lty = 2, lwd = .6, col = 'red')+
  theme(axis.title = element_text(size = 25),
        axis.text.x = element_text(size = 20),
        axis.text.y = element_text(size = 20),
        axis.line = element_line(size = 1.5),
        legend.title = element_text(size = 20, face = c('italic', 'bold')),
        legend.text = element_text(size = 20),
        legend.position = "top", legend.direction = "horizontal")


#***** Log RATIO between technical duplicated - the paper incorrectly called the log difference the ratio 
### Assessing the perfromance of RUV-III using 'leave out one duplicate'
DuplicatedSamples <- tuplicate(Nano_SampleInfo$Patient.barcodes, 2)
length(DuplicatedSamples) # 17
LogRatio_TechRep_RUVIII <- vector()
dataRUV <- t(log2(Nano_RawCounts[1:107, ] +1))

for(l in 1:length(DuplicatedSamples)){
  index <- Nano_SampleInfo$Patient.barcodes == DuplicatedSamples[l]
  info <- Nano_SampleInfo
  info$Patient.barcodes[index] <- c('Rep1', 'Rep2')
  X <- length(info$Patient.barcodes)
  Y <- length(unique(info$Patient.barcodes))
  
  ReplicateMatrix <- matrix(0, nrow = X, ncol = Y)
  row.names(ReplicateMatrix) <- info$Patient.barcodes
  colnames(ReplicateMatrix) <- unique(info$Patient.barcodes)
  for(i in 1:Y){
    n <- colnames(ReplicateMatrix)[i]
    sa <- which(row.names(ReplicateMatrix)==n)
    for(j in 1:length(sa)){
      ReplicateMatrix [sa[j] , i] <- 1
    }
  }
  RUVcorrected_Data <- ruv::RUVIII(dataRUV , ReplicateMatrix , ctl = ControlGenes, k = 2)
  RUVcorrected_Data <- t(RUVcorrected_Data)
  index <- which(index)
  LogRatio <- as.data.frame( (RUVcorrected_Data[ , index[1]] ) / (RUVcorrected_Data[ , index[2]]))
  colnames(LogRatio) <- 'LogRatio'
  LogRatio$Replicates <- rep(l , 107)
  LogRatio_TechRep_RUVIII <- rbind(LogRatio_TechRep_RUVIII , LogRatio)
  rm(i, index, info, X, Y, LogRatio)
  
}
nrow(LogRatio_TechRep_RUVIII)/107
LogRatio_TechRep_RUVIII$Datasets <- 'RUV-III normalized'


#***** Technical Replicate Agreement plot for unnormalized, Nanostring Normalization and RUV-III (leave out one technical replicate)
### Figure 1 B
TRAallNormalizations <- rbind(LogRatio_TechRep_RawCounts, LogRatio_TechRep_RUVIII)
TRAallNormalizations$Replicates <- as.factor(TRAallNormalizations$Replicates)
TRAallNormalizations$Datasets <- as.factor(TRAallNormalizations$Datasets)
TRAallNormalizations$Datasets  <- factor(TRAallNormalizations$Datasets , levels = c('Unnormalized','RUV-III normalized'))
ggplot(data = TRAallNormalizations) +
  geom_boxplot(aes(y = LogRatio, x = Replicates, fill = Datasets, color=Datasets), outlier.size = .5,
               position = position_dodge(width = .7),
               width = 1, alpha = 0.8, lwd = .7) +
  ylab('Log ratio')+ylim(c(-10,10)) +
  scale_color_manual(values = c('lightblue', 'royalblue', 'navy')) +
  scale_fill_manual(values = c('lightblue', 'royalblue', 'navy')) +
  theme_classic() +
  geom_hline(yintercept = 1, lty = 2, lwd = .6, col = 'red')+
  theme(axis.title = element_text(size = 25),
        axis.text.x = element_text(size = 20),
        axis.text.y = element_text(size = 20),
        axis.line = element_line(size = 1.5),
        legend.title = element_text(size = 20, face = c('italic', 'bold')),
        legend.text = element_text(size = 20),
        legend.position = "top", legend.direction = "horizontal")

############################################FINAL NORMALIZATION with 117 genes###################################################
length(Nano_SampleInfo$Patient.barcodes) # 162
length(unique(Nano_SampleInfo$Patient.barcodes)) # 135

ReplicateMatrix <- ruv::replicate.matrix(Nano_SampleInfo$Patient.barcodes)
dim(ReplicateMatrix) # 162 133
#***** Finding control genes
### Step 1: Using all genes as a set of negative control genes
# Performing RUVIII
dataRUV <- t(log2(Nano_RawCounts[1:107, ] +1))
RUVcorrected <- ruv::RUVIII(Y = dataRUV, M = ReplicateMatrix, ctl = c(1:107))
RUVcorrected <- t(RUVcorrected)

### Step 2: Selecting the most stable genes from step 1
LowVarGenes <- apply(RUVcorrected, 1, var)
ControlGenes <- which(LowVarGenes < .5)
length(ControlGenes) # 15 genes


### Step3: Performing RUV-III using the ControlGenes set
RUVcorrected <- RUVIII(Y = dataRUV, M = ReplicateMatrix, ctl = ControlGenes, k = 7)
RUVcorrected <- t(RUVcorrected)
dim(RUVcorrected)
# We tried different numbers of k based on our positive controls
all(colnames(RUVcorrected) == Nano_SampleInfo$SampleNames) ## TRUE

RUVcorrected_all = RUVcorrected
```

#Heatmap
```{r}
#normalized together ffpe
common_nanostring = RUVcorrected_all
pheatmap(common_nanostring)

common_nanostring = t(common_nanostring)
common_nanostring = as.data.frame(common_nanostring)

names = Nano_SampleInfo
names = dplyr::select(names, c("Patient.barcodes","SampleNames"))

common_nanostring = tibble::rownames_to_column(common_nanostring, "sample_id")


normcancer_ffpe = merge(common_nanostring, names, by.x="sample_id", by.y="SampleNames")
normcancer_ffpe = normcancer_ffpe[,-1]
colnames(normcancer_ffpe)[which(names(normcancer_ffpe) == "Patient.barcodes")] <- "sample_id"



normcancer_ffpe %>% group_by(sample_id) %>% summarise_all(mean) %>% data.frame() -> normcancer_ffpe
normcancer_ffpe = tibble::column_to_rownames(normcancer_ffpe, "sample_id")
pheatmap(normcancer_ffpe)

```


#RUV cancer/normal together organoid
```{r}
#***** Reading Nanostring gene expression raw data
Nano_ExpressionMatrix <- read.delim("~/Documents/PhD/Results: spreadsheets/Chapter 5/Nanostring/run1-7.txt",
                                    stringsAsFactors = FALSE, header = TRUE, as.is = TRUE)

#***** Reading sample and clinical information
Nano_SampleInfo <- read.delim("~/Documents/PhD/Results: spreadsheets/Chapter 5/Nanostring/nanostring_samples.txt",
                              stringsAsFactors = FALSE, header = TRUE, as.is = TRUE)
Nano_SampleInfo = Nano_SampleInfo[c(1:84),]

dim(Nano_SampleInfo) # 24 12
table(Nano_SampleInfo$Tissues)

#Exclude poor samples
exclude = Nano_SampleInfo$exclude=="TRUE" 
Nano_SampleInfo = Nano_SampleInfo[!(Nano_SampleInfo$exclude=="TRUE"),] 
Nano_SampleInfo = dplyr::select(Nano_SampleInfo, -"exclusion_reason")


Nano_RawCounts = dplyr::filter(Nano_ExpressionMatrix, subtype=="TCGA"| subtype=="TME"  | subtype=="Negative" | subtype=="Positive"| subtype=="Housekeeping")

#***** Expression matrix
Nano_RawCounts <- as.matrix(Nano_RawCounts[ , 5:ncol(Nano_RawCounts)])
exclude = colnames(Nano_RawCounts[,exclude])
Nano_RawCounts = Nano_RawCounts[ , !(colnames(Nano_RawCounts) %in% exclude)]



#Exclude organoids OR FFPE OR Cancer OR normal
exclude = Nano_SampleInfo$sample_type=="FFPE"
exclude = colnames(Nano_RawCounts[,exclude])
Nano_RawCounts = Nano_RawCounts[ , !(colnames(Nano_RawCounts) %in% exclude)]
Nano_SampleInfo = Nano_SampleInfo[!(Nano_SampleInfo$sample_type=="FFPE"),] 

row.names(Nano_RawCounts) <- Nano_ExpressionMatrix[Nano_ExpressionMatrix$subtype=="TCGA" | Nano_ExpressionMatrix$subtype=="TME" | Nano_ExpressionMatrix$subtype=="Negative" |Nano_ExpressionMatrix$subtype=="Positive" |Nano_ExpressionMatrix$subtype=="Housekeeping" ,]$Probe.Name
Nano_SampleInfo$SampleNames <- colnames(Nano_RawCounts)


##################################################################################################################################
##################################################################  Exploratory  data analysis – raw counts #####################
#***** Colors for each cartridges
Color_Batches <- c('purple','orange','darkred','blue','chartreuse',
                   'darkgoldenrod4','tan2','darkgreen','red3','darkmagenta',
                   'deeppink','violet','navy','red','dodgerblue')

#***** box plot of raw data - Endogenous genes only
RawCounts_log <- log2(Nano_RawCounts[1:107 , ]+1) # Excluding 7 housekeeping genes and Nanostring spike-ins
par(mar = c(6.5,6.5,2.3,0), mgp = c(3.7 , 1 , 0))
boxplot(RawCounts_log, las = 1, cex.axis = 2, ylab = '' , xlab = '', cex.lab = 4,
        xaxt = 'n', yaxt = 'n', main = 'Unnormalized counts', cex.main = 3.5,
        outline = FALSE, names = FALSE, frame = FALSE,
        whisklty = 3, whisklwd = 1.5, staplelty = 1, notch = TRUE, boxlwd = 2,
        staplelwd = 0 , boxcol = Color_Batches[factor(Nano_SampleInfo$Cartridges)],
        border = Color_Batches[factor(Nano_SampleInfo$cartridge)] , col='gray87')
box(lwd = 7, bty = 'l')
axis(1, cex.axis=1, at = c(1, seq(20,166,20)), cex.axis = 2.5, lwd.ticks = 4, mgp = c(3.5,1.6,0))
axis(2, at = c(0, seq(3,15,3)), mgp = c(3.5,.9,0), lwd.ticks = 4, las = 1, cex.axis=3)
mtext(expression(paste('Samples', '(', 'n'[samples], '=', '162', ')')), 1, line = 4.5, cex = 2.5)
mtext(expression(paste(Log[2],' (raw counts)')), 2, line = 3.5, cex = 2.7)


#***** RLE plot - Figure 1 A - Unormalized
par(mar = c(6.5,6.5,2.3,0))
boxplot(RawCounts_log - rowMedians(RawCounts_log),
        main = '', xlab = '', ylab = '', xaxt = 'n', yaxt = 'n', ylim = c(-4.1,4.1),
        outline = FALSE, names = FALSE, frame = FALSE, whisklty = 3, whisklwd = 1.5, staplelty = 1, notch = TRUE, boxlwd = 2,
        staplelwd = 0 , boxcol = Color_Batches[factor(Nano_SampleInfo$cartridge)],
        border = Color_Batches[factor(Nano_SampleInfo$cartridge)], col = 'gray87')
box(lwd = 7, bty = 'l')
title('Unnormalized counts', line = -2, cex.main = 3.5)
Median_RawData <- apply(RawCounts_log - rowMedians(RawCounts_log), 2, median)
points(c(1:ncol(RawCounts_log)), Median_RawData, col = Color_Batches[factor(Nano_SampleInfo$cartridge)], pch = 19, cex = 1.2)
axis(2, mgp = c(3.5, .9 ,0), lwd.ticks=6, las=1, cex.axis=3)
mtext('RLE', 2, line = 3.5, cex = 3.5)
abline(h = 0, col = 'black', lwd = 5, lty = 2)
par(lwd = 3)
legend(160, 4.1, legend = c(1,2,3,'.','.','.', 13,14,15),
       col = c(Color_Batches[1:3], rep('white', 3), Color_Batches[13:15]),
       pch = 19, bty = 'n', cex = 1.4)
text(x = 162, y = 4.2 ,labels  = 'Cartridges', cex = 1.5)
rm(Median_RawData)


#***** Average plot
### Average of Nanostring positive spike-ins controls
Mean_NegativeControlProbes <- apply(Nano_RawCounts[115:122, ], 2, mean)
### Average of Nanostring positive spike-ins controls
Mean_PositiveControlProbes <- apply(Nano_RawCounts[123:128, ], 2, mean)
### Average of housekeeping genes
Mean_HousekeepingGenes <- apply(Nano_RawCounts[108:114, ], 2, mean)
### Library size
LibrarySize <- colSums(Nano_RawCounts [ 1:128, ])

#### Average plots -  Supplementary Figure 2
par(mar = c(6,7,0,0))
plot(log2(LibrarySize), ylim = c(0,22), bty = 'l', typ = 'n', ylab = '', xlab = '', xaxt = 'n', yaxt = 'n')
axis(1, cex.axis = 1, at = c(1, seq(20,166,20)), cex.axis = 2, lwd.ticks = 4, mgp = c(3.5,1.4,0))
axis(2, cex.axis = 1, cex.axis = 2, lwd.ticks = 4, mgp = c(3.5,1,0), las = 1)
mtext(expression(paste(Log [2], ' (raw counts)')), 2, line = 3.5, cex = 3)
mtext(expression(paste('Samples', ' (', 'n'[samples], '=', '21', ')')), 1, line = 4.5, cex = 2.5)
X <- c(0,6,18,30,42,53,65,77,89,101,113,125,137,143,155,167)
GradiantColors <- paste0('gray', seq(90,20, by = -5))
for(i in 1:15) rect(X[i],-5, X[i+1], 22, col = GradiantColors[i], lty = 0 )
points(log2(LibrarySize), col = alpha('darkgoldenrod1', .8), pch = 15, cex = 1.8, lwd = 1.5)
lines(smooth.spline(c(1:length(LibrarySize)), log2(LibrarySize), df = 5), col = 'darkgoldenrod1', lwd = 4)
points(log2(Mean_HousekeepingGenes) + 3, cex = 2, col = alpha('red', .6), pch = 19)
lines(smooth.spline(c(1:length(LibrarySize)), log2(Mean_HousekeepingGenes) + 3, df = 5), col = 'red', lwd = 4)
points(log2(Mean_PositiveControlProbes) - 1, col = alpha('cyan2', .8), pch = 18, cex = 2.5)
lines(smooth.spline(c(1:length(LibrarySize)), log2(Mean_PositiveControlProbes) - 1, df = 5), col = 'cyan1', lwd = 4)
points(log2(Mean_NegativeControlProbes), col = alpha('green2', .6), pch = 17, cex = 1.8)
lines(smooth.spline(c(1:length(LibrarySize)), log2(Mean_NegativeControlProbes), df = 5), col = 'green2', lwd = 4)
box(lwd = 5, bty = 'l')
rm(X, GradiantColors, Mean_NegativeControlProbes,
   Mean_PositiveControlProbes, Mean_HousekeepingGenes,
   LibrarySize)


#***** Log ratio between all pairs of duplicated samples
DuplicatedSamples <- tuplicate(Nano_SampleInfo$Patient.barcodes, 2)
length(DuplicatedSamples) 

LogRatio_TechRep_RawCounts <- vector()
for(i in 1:1){
  index <- Nano_SampleInfo$Patient.barcodes == DuplicatedSamples[i]
  RepData <- RawCounts_log [ , index]
  LogRatio <- as.data.frame(RepData[ , 1] - RepData[ , 2] )
  colnames(LogRatio) <- 'LogRatio'
  LogRatio$Replicates <- rep( i , 107)
  LogRatio_TechRep_RawCounts <- rbind(LogRatio_TechRep_RawCounts , LogRatio)
  rm(i, index, RepData, LogRatio)
}
nrow(LogRatio_TechRep_RawCounts)/107 # 17
LogRatio_TechRep_RawCounts$Datasets <- 'Unnormalized'




##################################################################################################################################
############################################### RUV-III normalization - using technical replicates and control genes #############

#***** Creating replicate matrix
length(Nano_SampleInfo$Patient.barcodes) # 162
length(unique(Nano_SampleInfo$Patient.barcodes)) # 135

ReplicateMatrix <- ruv::replicate.matrix(Nano_SampleInfo$Patient.barcodes)
dim(ReplicateMatrix) # 162 133

### Making sure that every row has got only one number
par(mfrow = c(2,1))
barplot(colSums(ReplicateMatrix))
barplot(rowSums(ReplicateMatrix))
par(mfrow = c(1,1))


#***** Finding control genes
### Step 1: Using all genes as a set of negative control genes
# Performing RUVIII
dataRUV <- t(log2(Nano_RawCounts[1:107, ] + 1))
RUVcorrected <- ruv::RUVIII(Y = dataRUV, M = ReplicateMatrix, ctl = c(1:107))
RUVcorrected <- t(RUVcorrected)

### Step 2: Selecting the most stable genes from step 1
LowVarGenes <- apply(RUVcorrected, 1, var)
ControlGenes <- which(LowVarGenes < .5)
length(ControlGenes) # 15 genes


### Step3: Performing RUV-III using the ControlGenes set
RUVcorrected <- RUVIII(Y = dataRUV, M = ReplicateMatrix, ctl = ControlGenes, k = 7)
RUVcorrected <- t(RUVcorrected)
dim(RUVcorrected)
# We tried different numbers of k based on our positive controls####
all(colnames(RUVcorrected) == Nano_SampleInfo$SampleNames) ## TRUE


#***** RLE plots - Figure 1 A, RUV-III normalization
par(mar = c(6.5,6.5,2.3,0))
boxplot(RUVcorrected - rowMedians(RUVcorrected), main = '', xlab = '', ylab = '', xaxt = 'n', yaxt = 'n', ylim = c(-4.1,4.1),
        outline = FALSE, names = FALSE, frame = FALSE, whisklty = 3, whisklwd = 1.5, staplelty = 1, notch = TRUE, boxlwd = 2,
        staplelwd = 0 , boxcol = Color_Batches[factor(Nano_SampleInfo$cartridge)],
        border = Color_Batches[factor(Nano_SampleInfo$cartridge)], col = 'gray87')
box(lwd = 7, bty = 'l')
title('RUV-III normalized', line = -2, cex.main = 3.5)
Median_RUV <- apply(RUVcorrected - rowMedians(RUVcorrected), 2, median)
points(c(1:ncol(RUVcorrected)), Median_RUV, col = Color_Batches[factor(Nano_SampleInfo$cartridge)], pch = 19, cex = 1.2)
axis(1, cex.axis = 1, at = c(1, seq(20,166,20)), cex.axis = 2.5, lwd.ticks = 6,  mgp = c(3.5,1.6,0))
axis(2, mgp = c(3.5,.9,0), lwd.ticks = 6, las = 1, cex.axis = 3)
mtext(expression(paste('Samples','(', 'n'[samples], '=', '162', ')')),1 ,line = 5, cex = 3)
mtext('RLE', 2, line = 3.5, cex = 3.5)
abline(h = 0, col = 'black', lwd = 5, lty = 2)


#***** Correlation between ERCC1 and RRM1 in cancer samples
RUVIII_CancerData <- RUVcorrected[ , Nano_SampleInfo$Tissues=="cancer"]
dim(RUVIII_CancerData) ## 587 150
BioCo_RUV <- cor.test(unlist(t(RUVIII_CancerData['SMAD9' , ])) , unlist(t(RUVIII_CancerData[ 'JAK2' , ])), method = "spearman")[[4]]
par(mar = c(5,5,2,1))
plot (RUVIII_CancerData[ "SMAD9", ], RUVIII_CancerData [ "JAK2" , ],
      las = 1, pch = 21, col = "cyan", bg = 'blue', lwd = 1.2,
      main = "RUV-III normalized", bty = "l", cex.main = 2, mgp = c(3.2,.8,0),
      cex.axis = 1.7, cex.lab = 1.5, cex = 2.5, lwd.ticks = 3, ylab = "" ,
      xlab = expression(paste(italic(RRM1) , " (", log[2] , " normalized counts" , ")")))
mtext(expression(paste(italic(ERCC1) , " (", log[2] , " normalized counts" , ")")), 2, line = 3, cex = 1.5)
title(paste('(r = ', round(BioCo_RUV, digits = 2), ')'), line = -.5, cex = 1.4)
box(lwd = 6, bty = "l")


#***** Log DIFFERENCE between technical duplicated - per the paper
### Assessing the perfromance of RUV-III using 'leave out one duplicate'
DuplicatedSamples <- tuplicate(Nano_SampleInfo$Patient.barcodes, 2)
length(DuplicatedSamples) # 17
LogRatio_TechRep_RUVIII <- vector()
dataRUV <- t(log2(Nano_RawCounts[1:107, ] +1))

for(l in 1:length(DuplicatedSamples)){
  index <- Nano_SampleInfo$Patient.barcodes == DuplicatedSamples[l]
  info <- Nano_SampleInfo
  info$Patient.barcodes[index] <- c('Rep1', 'Rep2')
  X <- length(info$Patient.barcodes)
  Y <- length(unique(info$Patient.barcodes))
  
  ReplicateMatrix <- matrix(0, nrow = X, ncol = Y)
  row.names(ReplicateMatrix) <- info$Patient.barcodes
  colnames(ReplicateMatrix) <- unique(info$Patient.barcodes)
  for(i in 1:Y){
    n <- colnames(ReplicateMatrix)[i]
    sa <- which(row.names(ReplicateMatrix)==n)
    for(j in 1:length(sa)){
      ReplicateMatrix [sa[j] , i] <- 1
    }
  }
  RUVcorrected_Data <- ruv::RUVIII(dataRUV , ReplicateMatrix , ctl = ControlGenes, k = 2)
  RUVcorrected_Data <- t(RUVcorrected_Data)
  index <- which(index)
  LogRatio <- as.data.frame( (RUVcorrected_Data[ , index[1]] ) - (RUVcorrected_Data[ , index[2]]) )
  colnames(LogRatio) <- 'LogRatio'
  LogRatio$Replicates <- rep(l , 107)
  LogRatio_TechRep_RUVIII <- rbind(LogRatio_TechRep_RUVIII , LogRatio)
  rm(i, index, info, X, Y, LogRatio)
  
}
nrow(LogRatio_TechRep_RUVIII)/107
LogRatio_TechRep_RUVIII$Datasets <- 'RUV-III normalized'


#***** Technical Replicate Agreement plot for unnormalized, Nanostring Normalization and RUV-III (leave out one technical replicate)
### Figure 1 B
TRAallNormalizations <- rbind(LogRatio_TechRep_RawCounts, LogRatio_TechRep_RUVIII)
TRAallNormalizations$Replicates <- as.factor(TRAallNormalizations$Replicates)
TRAallNormalizations$Datasets <- as.factor(TRAallNormalizations$Datasets)
TRAallNormalizations$Datasets  <- factor(TRAallNormalizations$Datasets , levels = c('Unnormalized','RUV-III normalized'))
ggplot(data = TRAallNormalizations) +
  geom_boxplot(aes(y = LogRatio, x = Replicates, fill = Datasets, color=Datasets), outlier.size = .5,
               position = position_dodge(width = .7),
               width = 1, alpha = 0.8, lwd = .7) +
  ylab('Log ratio')+ylim(c(-10,10)) +
  scale_color_manual(values = c('lightblue', 'royalblue', 'navy')) +
  scale_fill_manual(values = c('lightblue', 'royalblue', 'navy')) +
  theme_classic() +
  geom_hline(yintercept = 0, lty = 2, lwd = .6, col = 'red')+
  theme(axis.title = element_text(size = 25),
        axis.text.x = element_text(size = 20),
        axis.text.y = element_text(size = 20),
        axis.line = element_line(size = 1.5),
        legend.title = element_text(size = 20, face = c('italic', 'bold')),
        legend.text = element_text(size = 20),
        legend.position = "top", legend.direction = "horizontal")


#***** Log RATIO between technical duplicated - the paper incorrectly called the log difference the ratio 
### Assessing the perfromance of RUV-III using 'leave out one duplicate'
DuplicatedSamples <- tuplicate(Nano_SampleInfo$Patient.barcodes, 2)
length(DuplicatedSamples) # 17
LogRatio_TechRep_RUVIII <- vector()
dataRUV <- t(log2(Nano_RawCounts[1:107, ] +1))

for(l in 1:length(DuplicatedSamples)){
  index <- Nano_SampleInfo$Patient.barcodes == DuplicatedSamples[l]
  info <- Nano_SampleInfo
  info$Patient.barcodes[index] <- c('Rep1', 'Rep2')
  X <- length(info$Patient.barcodes)
  Y <- length(unique(info$Patient.barcodes))
  
  ReplicateMatrix <- matrix(0, nrow = X, ncol = Y)
  row.names(ReplicateMatrix) <- info$Patient.barcodes
  colnames(ReplicateMatrix) <- unique(info$Patient.barcodes)
  for(i in 1:Y){
    n <- colnames(ReplicateMatrix)[i]
    sa <- which(row.names(ReplicateMatrix)==n)
    for(j in 1:length(sa)){
      ReplicateMatrix [sa[j] , i] <- 1
    }
  }
  RUVcorrected_Data <- ruv::RUVIII(dataRUV , ReplicateMatrix , ctl = ControlGenes, k = 2)
  RUVcorrected_Data <- t(RUVcorrected_Data)
  index <- which(index)
  LogRatio <- as.data.frame( (RUVcorrected_Data[ , index[1]] ) / (RUVcorrected_Data[ , index[2]]))
  colnames(LogRatio) <- 'LogRatio'
  LogRatio$Replicates <- rep(l , 107)
  LogRatio_TechRep_RUVIII <- rbind(LogRatio_TechRep_RUVIII , LogRatio)
  rm(i, index, info, X, Y, LogRatio)
  
}
nrow(LogRatio_TechRep_RUVIII)/107
LogRatio_TechRep_RUVIII$Datasets <- 'RUV-III normalized'


#***** Technical Replicate Agreement plot for unnormalized, Nanostring Normalization and RUV-III (leave out one technical replicate)
### Figure 1 B
TRAallNormalizations <- rbind(LogRatio_TechRep_RawCounts, LogRatio_TechRep_RUVIII)
TRAallNormalizations$Replicates <- as.factor(TRAallNormalizations$Replicates)
TRAallNormalizations$Datasets <- as.factor(TRAallNormalizations$Datasets)
TRAallNormalizations$Datasets  <- factor(TRAallNormalizations$Datasets , levels = c('Unnormalized','RUV-III normalized'))
ggplot(data = TRAallNormalizations) +
  geom_boxplot(aes(y = LogRatio, x = Replicates, fill = Datasets, color=Datasets), outlier.size = .5,
               position = position_dodge(width = .7),
               width = 1, alpha = 0.8, lwd = .7) +
  ylab('Log ratio')+ylim(c(-10,10)) +
  scale_color_manual(values = c('lightblue', 'royalblue', 'navy')) +
  scale_fill_manual(values = c('lightblue', 'royalblue', 'navy')) +
  theme_classic() +
  geom_hline(yintercept = 1, lty = 2, lwd = .6, col = 'red')+
  theme(axis.title = element_text(size = 25),
        axis.text.x = element_text(size = 20),
        axis.text.y = element_text(size = 20),
        axis.line = element_line(size = 1.5),
        legend.title = element_text(size = 20, face = c('italic', 'bold')),
        legend.text = element_text(size = 20),
        legend.position = "top", legend.direction = "horizontal")

############################################FINAL NORMALIZATION with 117 genes###################################################
length(Nano_SampleInfo$Patient.barcodes) # 162
length(unique(Nano_SampleInfo$Patient.barcodes)) # 135

ReplicateMatrix <- ruv::replicate.matrix(Nano_SampleInfo$Patient.barcodes)
dim(ReplicateMatrix) # 162 133
#***** Finding control genes
### Step 1: Using all genes as a set of negative control genes
# Performing RUVIII
dataRUV <- t(log2(Nano_RawCounts[1:107, ] +1))
RUVcorrected <- ruv::RUVIII(Y = dataRUV, M = ReplicateMatrix, ctl = c(1:107))
RUVcorrected <- t(RUVcorrected)

### Step 2: Selecting the most stable genes from step 1
LowVarGenes <- apply(RUVcorrected, 1, var)
ControlGenes <- which(LowVarGenes < .5)
length(ControlGenes) # 15 genes


### Step3: Performing RUV-III using the ControlGenes set
RUVcorrected <- RUVIII(Y = dataRUV, M = ReplicateMatrix, ctl = ControlGenes, k = 7)
RUVcorrected <- t(RUVcorrected)
dim(RUVcorrected)
# We tried different numbers of k based on our positive controls
all(colnames(RUVcorrected) == Nano_SampleInfo$SampleNames) ## TRUE

RUVcorrected_all_organoid = RUVcorrected
```

#Heatmap
```{r}
#normalized together ffpe
common_nanostring = RUVcorrected_all_organoid
pheatmap(common_nanostring)

common_nanostring = t(common_nanostring)
common_nanostring = as.data.frame(common_nanostring)

names = Nano_SampleInfo
names = dplyr::select(names, c("Patient.barcodes","SampleNames"))

common_nanostring = tibble::rownames_to_column(common_nanostring, "sample_id")


normcancer_organoid = merge(common_nanostring, names, by.x="sample_id", by.y="SampleNames")
normcancer_organoid = normcancer_organoid[,-1]
colnames(normcancer_organoid)[which(names(normcancer_organoid) == "Patient.barcodes")] <- "sample_id"



normcancer_organoid %>% group_by(sample_id) %>% summarise_all(mean) %>% data.frame() -> normcancer_organoid
normcancer_organoid = tibble::column_to_rownames(normcancer_organoid, "sample_id")
pheatmap(normcancer_organoid)

```


####dfdf



#RUV cancer/normal together FFPE
```{r}
#***** Reading Nanostring gene expression raw data
Nano_ExpressionMatrix <- read.delim("~/Documents/PhD/Results: spreadsheets/Chapter 5/Nanostring/run1-7.txt",
                                    stringsAsFactors = FALSE, header = TRUE, as.is = TRUE)

#***** Reading sample and clinical information
Nano_SampleInfo <- read.delim("~/Documents/PhD/Results: spreadsheets/Chapter 5/Nanostring/nanostring_samples.txt",
                              stringsAsFactors = FALSE, header = TRUE, as.is = TRUE)
Nano_SampleInfo = Nano_SampleInfo[c(1:84),]

dim(Nano_SampleInfo) # 24 12
table(Nano_SampleInfo$Tissues)

#Exclude poor samples
exclude = Nano_SampleInfo$exclude=="TRUE" 
Nano_SampleInfo = Nano_SampleInfo[!(Nano_SampleInfo$exclude=="TRUE"),] 
Nano_SampleInfo = dplyr::select(Nano_SampleInfo, -"exclusion_reason")


Nano_RawCounts = dplyr::filter(Nano_ExpressionMatrix, subtype=="Normal/Cancer"| subtype=="TCGA"| subtype=="TME"  | subtype=="Negative" | subtype=="Positive"| subtype=="Housekeeping")

#***** Expression matrix
Nano_RawCounts <- as.matrix(Nano_RawCounts[ , 5:ncol(Nano_RawCounts)])
exclude = colnames(Nano_RawCounts[,exclude])
Nano_RawCounts = Nano_RawCounts[ , !(colnames(Nano_RawCounts) %in% exclude)]



#Exclude organoids OR FFPE OR Cancer OR normal
exclude = Nano_SampleInfo$sample_type=="organoid"
exclude = colnames(Nano_RawCounts[,exclude])
Nano_RawCounts = Nano_RawCounts[ , !(colnames(Nano_RawCounts) %in% exclude)]
Nano_SampleInfo = Nano_SampleInfo[!(Nano_SampleInfo$sample_type=="organoid"),] 

row.names(Nano_RawCounts) <- Nano_ExpressionMatrix[Nano_ExpressionMatrix$subtype=="Normal/Cancer" |Nano_ExpressionMatrix$subtype=="TCGA" | Nano_ExpressionMatrix$subtype=="TME" | Nano_ExpressionMatrix$subtype=="Negative" |Nano_ExpressionMatrix$subtype=="Positive" |Nano_ExpressionMatrix$subtype=="Housekeeping" ,]$Probe.Name
Nano_SampleInfo$SampleNames <- colnames(Nano_RawCounts)


##################################################################################################################################
##################################################################  Exploratory  data analysis – raw counts #####################
#***** Colors for each cartridges
Color_Batches <- c('purple','orange','darkred','blue','chartreuse',
                   'darkgoldenrod4','tan2','darkgreen','red3','darkmagenta',
                   'deeppink','violet','navy','red','dodgerblue')

#***** box plot of raw data - Endogenous genes only
RawCounts_log <- log2(Nano_RawCounts[1:117 , ]+1) # Excluding 7 housekeeping genes and Nanostring spike-ins
par(mar = c(6.5,6.5,2.3,0), mgp = c(3.7 , 1 , 0))
boxplot(RawCounts_log, las = 1, cex.axis = 2, ylab = '' , xlab = '', cex.lab = 4,
        xaxt = 'n', yaxt = 'n', main = 'Unnormalized counts', cex.main = 3.5,
        outline = FALSE, names = FALSE, frame = FALSE,
        whisklty = 3, whisklwd = 1.5, staplelty = 1, notch = TRUE, boxlwd = 2,
        staplelwd = 0 , boxcol = Color_Batches[factor(Nano_SampleInfo$Cartridges)],
        border = Color_Batches[factor(Nano_SampleInfo$cartridge)] , col='gray87')
box(lwd = 7, bty = 'l')
axis(1, cex.axis=1, at = c(1, seq(20,166,20)), cex.axis = 2.5, lwd.ticks = 4, mgp = c(3.5,1.6,0))
axis(2, at = c(0, seq(3,15,3)), mgp = c(3.5,.9,0), lwd.ticks = 4, las = 1, cex.axis=3)
mtext(expression(paste('Samples', '(', 'n'[samples], '=', '162', ')')), 1, line = 4.5, cex = 2.5)
mtext(expression(paste(Log[2],' (raw counts)')), 2, line = 3.5, cex = 2.7)


#***** RLE plot - Figure 1 A - Unormalized
par(mar = c(6.5,6.5,2.3,0))
boxplot(RawCounts_log - rowMedians(RawCounts_log),
        main = '', xlab = '', ylab = '', xaxt = 'n', yaxt = 'n', ylim = c(-4.1,4.1),
        outline = FALSE, names = FALSE, frame = FALSE, whisklty = 3, whisklwd = 1.5, staplelty = 1, notch = TRUE, boxlwd = 2,
        staplelwd = 0 , boxcol = Color_Batches[factor(Nano_SampleInfo$cartridge)],
        border = Color_Batches[factor(Nano_SampleInfo$cartridge)], col = 'gray87')
box(lwd = 7, bty = 'l')
title('Unnormalized counts', line = -2, cex.main = 3.5)
Median_RawData <- apply(RawCounts_log - rowMedians(RawCounts_log), 2, median)
points(c(1:ncol(RawCounts_log)), Median_RawData, col = Color_Batches[factor(Nano_SampleInfo$cartridge)], pch = 19, cex = 1.2)
axis(2, mgp = c(3.5, .9 ,0), lwd.ticks=6, las=1, cex.axis=3)
mtext('RLE', 2, line = 3.5, cex = 3.5)
abline(h = 0, col = 'black', lwd = 5, lty = 2)
par(lwd = 3)
legend(160, 4.1, legend = c(1,2,3,'.','.','.', 13,14,15),
       col = c(Color_Batches[1:3], rep('white', 3), Color_Batches[13:15]),
       pch = 19, bty = 'n', cex = 1.4)
text(x = 162, y = 4.2 ,labels  = 'Cartridges', cex = 1.5)
rm(Median_RawData)


#***** Average plot
### Average of Nanostring positive spike-ins controls
Mean_NegativeControlProbes <- apply(Nano_RawCounts[115:122, ], 2, mean)
### Average of Nanostring positive spike-ins controls
Mean_PositiveControlProbes <- apply(Nano_RawCounts[123:128, ], 2, mean)
### Average of housekeeping genes
Mean_HousekeepingGenes <- apply(Nano_RawCounts[108:114, ], 2, mean)
### Library size
LibrarySize <- colSums(Nano_RawCounts [ 1:128, ])

#### Average plots -  Supplementary Figure 2
par(mar = c(6,7,0,0))
plot(log2(LibrarySize), ylim = c(0,22), bty = 'l', typ = 'n', ylab = '', xlab = '', xaxt = 'n', yaxt = 'n')
axis(1, cex.axis = 1, at = c(1, seq(20,166,20)), cex.axis = 2, lwd.ticks = 4, mgp = c(3.5,1.4,0))
axis(2, cex.axis = 1, cex.axis = 2, lwd.ticks = 4, mgp = c(3.5,1,0), las = 1)
mtext(expression(paste(Log [2], ' (raw counts)')), 2, line = 3.5, cex = 3)
mtext(expression(paste('Samples', ' (', 'n'[samples], '=', '21', ')')), 1, line = 4.5, cex = 2.5)
X <- c(0,6,18,30,42,53,65,77,89,101,113,125,137,143,155,167)
GradiantColors <- paste0('gray', seq(90,20, by = -5))
for(i in 1:15) rect(X[i],-5, X[i+1], 22, col = GradiantColors[i], lty = 0 )
points(log2(LibrarySize), col = alpha('darkgoldenrod1', .8), pch = 15, cex = 1.8, lwd = 1.5)
lines(smooth.spline(c(1:length(LibrarySize)), log2(LibrarySize), df = 5), col = 'darkgoldenrod1', lwd = 4)
points(log2(Mean_HousekeepingGenes) + 3, cex = 2, col = alpha('red', .6), pch = 19)
lines(smooth.spline(c(1:length(LibrarySize)), log2(Mean_HousekeepingGenes) + 3, df = 5), col = 'red', lwd = 4)
points(log2(Mean_PositiveControlProbes) - 1, col = alpha('cyan2', .8), pch = 18, cex = 2.5)
lines(smooth.spline(c(1:length(LibrarySize)), log2(Mean_PositiveControlProbes) - 1, df = 5), col = 'cyan1', lwd = 4)
points(log2(Mean_NegativeControlProbes), col = alpha('green2', .6), pch = 17, cex = 1.8)
lines(smooth.spline(c(1:length(LibrarySize)), log2(Mean_NegativeControlProbes), df = 5), col = 'green2', lwd = 4)
box(lwd = 5, bty = 'l')
rm(X, GradiantColors, Mean_NegativeControlProbes,
   Mean_PositiveControlProbes, Mean_HousekeepingGenes,
   LibrarySize)


#***** Log ratio between all pairs of duplicated samples
DuplicatedSamples <- tuplicate(Nano_SampleInfo$Patient.barcodes, 2)
length(DuplicatedSamples) 

LogRatio_TechRep_RawCounts <- vector()
for(i in 1:1){
  index <- Nano_SampleInfo$Patient.barcodes == DuplicatedSamples[i]
  RepData <- RawCounts_log [ , index]
  LogRatio <- as.data.frame(RepData[ , 1] - RepData[ , 2] )
  colnames(LogRatio) <- 'LogRatio'
  LogRatio$Replicates <- rep( i , 117)
  LogRatio_TechRep_RawCounts <- rbind(LogRatio_TechRep_RawCounts , LogRatio)
  rm(i, index, RepData, LogRatio)
}
nrow(LogRatio_TechRep_RawCounts)/117 # 17
LogRatio_TechRep_RawCounts$Datasets <- 'Unnormalized'




##################################################################################################################################
############################################### RUV-III normalization - using technical replicates and control genes #############

#***** Creating replicate matrix
length(Nano_SampleInfo$Patient.barcodes) # 162
length(unique(Nano_SampleInfo$Patient.barcodes)) # 135

ReplicateMatrix <- ruv::replicate.matrix(Nano_SampleInfo$Patient.barcodes)
dim(ReplicateMatrix) # 162 133

### Making sure that every row has got only one number
par(mfrow = c(2,1))
barplot(colSums(ReplicateMatrix))
barplot(rowSums(ReplicateMatrix))
par(mfrow = c(1,1))


#***** Finding control genes
### Step 1: Using all genes as a set of negative control genes
# Performing RUVIII
dataRUV <- t(log2(Nano_RawCounts[1:117, ] + 1))
RUVcorrected <- ruv::RUVIII(Y = dataRUV, M = ReplicateMatrix, ctl = c(1:117))
RUVcorrected <- t(RUVcorrected)

### Step 2: Selecting the most stable genes from step 1
LowVarGenes <- apply(RUVcorrected, 1, var)
ControlGenes <- which(LowVarGenes < .5)
length(ControlGenes) # 15 genes


### Step3: Performing RUV-III using the ControlGenes set
RUVcorrected <- RUVIII(Y = dataRUV, M = ReplicateMatrix, ctl = ControlGenes, k = 7)
RUVcorrected <- t(RUVcorrected)
dim(RUVcorrected)
# We tried different numbers of k based on our positive controls####
all(colnames(RUVcorrected) == Nano_SampleInfo$SampleNames) ## TRUE


#***** RLE plots - Figure 1 A, RUV-III normalization
par(mar = c(6.5,6.5,2.3,0))
boxplot(RUVcorrected - rowMedians(RUVcorrected), main = '', xlab = '', ylab = '', xaxt = 'n', yaxt = 'n', ylim = c(-4.1,4.1),
        outline = FALSE, names = FALSE, frame = FALSE, whisklty = 3, whisklwd = 1.5, staplelty = 1, notch = TRUE, boxlwd = 2,
        staplelwd = 0 , boxcol = Color_Batches[factor(Nano_SampleInfo$cartridge)],
        border = Color_Batches[factor(Nano_SampleInfo$cartridge)], col = 'gray87')
box(lwd = 7, bty = 'l')
title('RUV-III normalized', line = -2, cex.main = 3.5)
Median_RUV <- apply(RUVcorrected - rowMedians(RUVcorrected), 2, median)
points(c(1:ncol(RUVcorrected)), Median_RUV, col = Color_Batches[factor(Nano_SampleInfo$cartridge)], pch = 19, cex = 1.2)
axis(1, cex.axis = 1, at = c(1, seq(20,166,20)), cex.axis = 2.5, lwd.ticks = 6,  mgp = c(3.5,1.6,0))
axis(2, mgp = c(3.5,.9,0), lwd.ticks = 6, las = 1, cex.axis = 3)
mtext(expression(paste('Samples','(', 'n'[samples], '=', '162', ')')),1 ,line = 5, cex = 3)
mtext('RLE', 2, line = 3.5, cex = 3.5)
abline(h = 0, col = 'black', lwd = 5, lty = 2)


#***** Correlation between ERCC1 and RRM1 in cancer samples
RUVIII_CancerData <- RUVcorrected[ , Nano_SampleInfo$Tissues=="cancer"]
dim(RUVIII_CancerData) ## 587 150
BioCo_RUV <- cor.test(unlist(t(RUVIII_CancerData['SMAD9' , ])) , unlist(t(RUVIII_CancerData[ 'JAK2' , ])), method = "spearman")[[4]]
par(mar = c(5,5,2,1))
plot (RUVIII_CancerData[ "SMAD9", ], RUVIII_CancerData [ "JAK2" , ],
      las = 1, pch = 21, col = "cyan", bg = 'blue', lwd = 1.2,
      main = "RUV-III normalized", bty = "l", cex.main = 2, mgp = c(3.2,.8,0),
      cex.axis = 1.7, cex.lab = 1.5, cex = 2.5, lwd.ticks = 3, ylab = "" ,
      xlab = expression(paste(italic(RRM1) , " (", log[2] , " normalized counts" , ")")))
mtext(expression(paste(italic(ERCC1) , " (", log[2] , " normalized counts" , ")")), 2, line = 3, cex = 1.5)
title(paste('(r = ', round(BioCo_RUV, digits = 2), ')'), line = -.5, cex = 1.4)
box(lwd = 6, bty = "l")


#***** Log DIFFERENCE between technical duplicated - per the paper
### Assessing the perfromance of RUV-III using 'leave out one duplicate'
DuplicatedSamples <- tuplicate(Nano_SampleInfo$Patient.barcodes, 2)
length(DuplicatedSamples) # 17
LogRatio_TechRep_RUVIII <- vector()
dataRUV <- t(log2(Nano_RawCounts[1:117, ] +1))

for(l in 1:length(DuplicatedSamples)){
  index <- Nano_SampleInfo$Patient.barcodes == DuplicatedSamples[l]
  info <- Nano_SampleInfo
  info$Patient.barcodes[index] <- c('Rep1', 'Rep2')
  X <- length(info$Patient.barcodes)
  Y <- length(unique(info$Patient.barcodes))
  
  ReplicateMatrix <- matrix(0, nrow = X, ncol = Y)
  row.names(ReplicateMatrix) <- info$Patient.barcodes
  colnames(ReplicateMatrix) <- unique(info$Patient.barcodes)
  for(i in 1:Y){
    n <- colnames(ReplicateMatrix)[i]
    sa <- which(row.names(ReplicateMatrix)==n)
    for(j in 1:length(sa)){
      ReplicateMatrix [sa[j] , i] <- 1
    }
  }
  RUVcorrected_Data <- ruv::RUVIII(dataRUV , ReplicateMatrix , ctl = ControlGenes, k = 7)
  RUVcorrected_Data <- t(RUVcorrected_Data)
  index <- which(index)
  LogRatio <- as.data.frame( (RUVcorrected_Data[ , index[1]] ) - (RUVcorrected_Data[ , index[2]]) )
  colnames(LogRatio) <- 'LogRatio'
  LogRatio$Replicates <- rep(l , 117)
  LogRatio_TechRep_RUVIII <- rbind(LogRatio_TechRep_RUVIII , LogRatio)
  rm(i, index, info, X, Y, LogRatio)
  
}
nrow(LogRatio_TechRep_RUVIII)/117
LogRatio_TechRep_RUVIII$Datasets <- 'RUV-III normalized'


#***** Technical Replicate Agreement plot for unnormalized, Nanostring Normalization and RUV-III (leave out one technical replicate)
### Figure 1 B
TRAallNormalizations <- rbind(LogRatio_TechRep_RawCounts, LogRatio_TechRep_RUVIII)
TRAallNormalizations$Replicates <- as.factor(TRAallNormalizations$Replicates)
TRAallNormalizations$Datasets <- as.factor(TRAallNormalizations$Datasets)
TRAallNormalizations$Datasets  <- factor(TRAallNormalizations$Datasets , levels = c('Unnormalized','RUV-III normalized'))
ggplot(data = TRAallNormalizations) +
  geom_boxplot(aes(y = LogRatio, x = Replicates, fill = Datasets, color=Datasets), outlier.size = .5,
               position = position_dodge(width = .7),
               width = 1, alpha = 0.8, lwd = .7) +
  ylab('Log ratio')+ylim(c(-10,10)) +
  scale_color_manual(values = c('lightblue', 'royalblue', 'navy')) +
  scale_fill_manual(values = c('lightblue', 'royalblue', 'navy')) +
  theme_classic() +
  geom_hline(yintercept = 0, lty = 2, lwd = .6, col = 'red')+
  theme(axis.title = element_text(size = 25),
        axis.text.x = element_text(size = 20),
        axis.text.y = element_text(size = 20),
        axis.line = element_line(size = 1.5),
        legend.title = element_text(size = 20, face = c('italic', 'bold')),
        legend.text = element_text(size = 20),
        legend.position = "top", legend.direction = "horizontal")


#***** Log RATIO between technical duplicated - the paper incorrectly called the log difference the ratio 
### Assessing the perfromance of RUV-III using 'leave out one duplicate'
DuplicatedSamples <- tuplicate(Nano_SampleInfo$Patient.barcodes, 2)
length(DuplicatedSamples) # 17
LogRatio_TechRep_RUVIII <- vector()
dataRUV <- t(log2(Nano_RawCounts[1:117, ] +1))

for(l in 1:length(DuplicatedSamples)){
  index <- Nano_SampleInfo$Patient.barcodes == DuplicatedSamples[l]
  info <- Nano_SampleInfo
  info$Patient.barcodes[index] <- c('Rep1', 'Rep2')
  X <- length(info$Patient.barcodes)
  Y <- length(unique(info$Patient.barcodes))
  
  ReplicateMatrix <- matrix(0, nrow = X, ncol = Y)
  row.names(ReplicateMatrix) <- info$Patient.barcodes
  colnames(ReplicateMatrix) <- unique(info$Patient.barcodes)
  for(i in 1:Y){
    n <- colnames(ReplicateMatrix)[i]
    sa <- which(row.names(ReplicateMatrix)==n)
    for(j in 1:length(sa)){
      ReplicateMatrix [sa[j] , i] <- 1
    }
  }
  RUVcorrected_Data <- ruv::RUVIII(dataRUV , ReplicateMatrix , ctl = ControlGenes, k = 7)
  RUVcorrected_Data <- t(RUVcorrected_Data)
  index <- which(index)
  LogRatio <- as.data.frame( (RUVcorrected_Data[ , index[1]] ) / (RUVcorrected_Data[ , index[2]]))
  colnames(LogRatio) <- 'LogRatio'
  LogRatio$Replicates <- rep(l , 117)
  LogRatio_TechRep_RUVIII <- rbind(LogRatio_TechRep_RUVIII , LogRatio)
  rm(i, index, info, X, Y, LogRatio)
  
}
nrow(LogRatio_TechRep_RUVIII)/117
LogRatio_TechRep_RUVIII$Datasets <- 'RUV-III normalized'


#***** Technical Replicate Agreement plot for unnormalized, Nanostring Normalization and RUV-III (leave out one technical replicate)
### Figure 1 B
TRAallNormalizations <- rbind(LogRatio_TechRep_RawCounts, LogRatio_TechRep_RUVIII)
TRAallNormalizations$Replicates <- as.factor(TRAallNormalizations$Replicates)
TRAallNormalizations$Datasets <- as.factor(TRAallNormalizations$Datasets)
TRAallNormalizations$Datasets  <- factor(TRAallNormalizations$Datasets , levels = c('Unnormalized','RUV-III normalized'))
ggplot(data = TRAallNormalizations) +
  geom_boxplot(aes(y = LogRatio, x = Replicates, fill = Datasets, color=Datasets), outlier.size = .5,
               position = position_dodge(width = .7),
               width = 1, alpha = 0.8, lwd = .7) +
  ylab('Log ratio')+ylim(c(-10,10)) +
  scale_color_manual(values = c('lightblue', 'royalblue', 'navy')) +
  scale_fill_manual(values = c('lightblue', 'royalblue', 'navy')) +
  theme_classic() +
  geom_hline(yintercept = 1, lty = 2, lwd = .6, col = 'red')+
  theme(axis.title = element_text(size = 25),
        axis.text.x = element_text(size = 20),
        axis.text.y = element_text(size = 20),
        axis.line = element_line(size = 1.5),
        legend.title = element_text(size = 20, face = c('italic', 'bold')),
        legend.text = element_text(size = 20),
        legend.position = "top", legend.direction = "horizontal")

############################################FINAL NORMALIZATION with 117 genes###################################################
length(Nano_SampleInfo$Patient.barcodes) # 162
length(unique(Nano_SampleInfo$Patient.barcodes)) # 135

ReplicateMatrix <- ruv::replicate.matrix(Nano_SampleInfo$Patient.barcodes)
dim(ReplicateMatrix) # 162 133
#***** Finding control genes
### Step 1: Using all genes as a set of negative control genes
# Performing RUVIII
dataRUV <- t(log2(Nano_RawCounts[1:117, ] +1))
RUVcorrected <- ruv::RUVIII(Y = dataRUV, M = ReplicateMatrix, ctl = c(1:117))
RUVcorrected <- t(RUVcorrected)

### Step 2: Selecting the most stable genes from step 1
LowVarGenes <- apply(RUVcorrected, 1, var)
ControlGenes <- which(LowVarGenes < .5)
length(ControlGenes) # 15 genes


### Step3: Performing RUV-III using the ControlGenes set
RUVcorrected <- RUVIII(Y = dataRUV, M = ReplicateMatrix, ctl = ControlGenes, k = 7)
RUVcorrected <- t(RUVcorrected)
dim(RUVcorrected)
# We tried different numbers of k based on our positive controls
all(colnames(RUVcorrected) == Nano_SampleInfo$SampleNames) ## TRUE

RUVcorrected_all = RUVcorrected
```

#Heatmap
```{r}
#normalized together ffpe
common_nanostring = RUVcorrected_all
pheatmap(common_nanostring)

common_nanostring = t(common_nanostring)
common_nanostring = as.data.frame(common_nanostring)

names = Nano_SampleInfo
names = dplyr::select(names, c("Patient.barcodes","SampleNames"))

common_nanostring = tibble::rownames_to_column(common_nanostring, "sample_id")


normcancer_ffpe = merge(common_nanostring, names, by.x="sample_id", by.y="SampleNames")
normcancer_ffpe = normcancer_ffpe[,-1]
colnames(normcancer_ffpe)[which(names(normcancer_ffpe) == "Patient.barcodes")] <- "sample_id"




normcancer_ffpe %>% group_by(sample_id) %>% summarise_all(mean) %>% data.frame() -> normcancer_ffpe
normcancer_ffpe = tibble::column_to_rownames(normcancer_ffpe, "sample_id")

normalgenes <- Nano_ExpressionMatrix[Nano_ExpressionMatrix$subtype=="Normal/Cancer",]$Probe.Name
#normcancer_ffpe <- normcancer_ffpe[, normalgenes]

pheatmap(normcancer_ffpe)

```

#PCA test 
```{r}

RUVcorrected_all

normcancer_ffpe

normcancer_ffpe
pdata = row.names(normcancer_ffpe)
pdata = as.data.frame(pdata)
pdata$source = ifelse(grepl("67C", pdata$pdata, ignore.case = T), "Normal", ifelse(grepl("N", pdata$pdata, ignore.case = T), "Normal","Cancer"))
pdata$source = as.factor(pdata$source)


svd1 = svd(RUVcorrected_all - rowMeans(RUVcorrected_all))
plot(svd1$v[,1],svd1$v[,2],xlab="PC1",ylab="PC2",col=as.factor(pdata$source))
plot(svd1$v[,1],svd1$v[,2],xlab="PC1",ylab="PC2",col=as.factor(pdata$pdata))

```
#Model

```{r}

train = normcancer_ffpe
train$source = pdata$source

#Upsample training data
data_one_up = recipe(source~., data=train) %>% step_upsample(source, over_ratio = 0.5) %>% prep()

###HERE you need to try various oversampling ratios. In this case oversampling to 0.5 or even 0.1 causes singularities  

training <- data_one_up %>%
  bake(new_data = NULL) %>%
  dplyr::count(source, name='training')
training

x_train = data_one_up %>%
  bake(new_data = NULL)

x= data.matrix(x_train[,-118])
y= x_train$source
y = as.factor(y)

#Make our test and train data
#x= data.matrix(normcancer_ffpe)
#y= pdata$source
#y = as.factor(y)

```

# glmNET LASSO - Optimal performance on individual classification (Grouped data assessment not shown)

```{r}
set.seed(99)
model = caret::train(x,y,'glmnet',trControl=trainControl(method='boot632',  number=500))


predict.lasso.10fold = predict(lasso.10fold, x.test, type="class")
table.lasso.10fold = table(predict.lasso.10fold, y.test)
full.lasso1 = confusionMatrix(table.lasso.10fold, mode = "everything")
full.lasso1
```



#RUV cancer/normal together organoid
```{r}
#***** Reading Nanostring gene expression raw data
Nano_ExpressionMatrix <- read.delim("~/Documents/PhD/Results: spreadsheets/Chapter 5/Nanostring/run1-7.txt",
                                    stringsAsFactors = FALSE, header = TRUE, as.is = TRUE)

#***** Reading sample and clinical information
Nano_SampleInfo <- read.delim("~/Documents/PhD/Results: spreadsheets/Chapter 5/Nanostring/nanostring_samples.txt",
                              stringsAsFactors = FALSE, header = TRUE, as.is = TRUE)
Nano_SampleInfo = Nano_SampleInfo[c(1:84),]

dim(Nano_SampleInfo) # 24 12
table(Nano_SampleInfo$Tissues)

#Exclude poor samples
exclude = Nano_SampleInfo$exclude=="TRUE" 
Nano_SampleInfo = Nano_SampleInfo[!(Nano_SampleInfo$exclude=="TRUE"),] 
Nano_SampleInfo = dplyr::select(Nano_SampleInfo, -"exclusion_reason")


Nano_RawCounts = dplyr::filter(Nano_ExpressionMatrix, subtype=="Normal/Cancer"| subtype=="TCGA"| subtype=="TME"  | subtype=="Negative" | subtype=="Positive"| subtype=="Housekeeping")

#***** Expression matrix
Nano_RawCounts <- as.matrix(Nano_RawCounts[ , 5:ncol(Nano_RawCounts)])
exclude = colnames(Nano_RawCounts[,exclude])
Nano_RawCounts = Nano_RawCounts[ , !(colnames(Nano_RawCounts) %in% exclude)]



#Exclude organoids OR FFPE OR Cancer OR normal
exclude = Nano_SampleInfo$sample_type=="FFPE"
exclude = colnames(Nano_RawCounts[,exclude])
Nano_RawCounts = Nano_RawCounts[ , !(colnames(Nano_RawCounts) %in% exclude)]
Nano_SampleInfo = Nano_SampleInfo[!(Nano_SampleInfo$sample_type=="FFPE"),] 


row.names(Nano_RawCounts) <- Nano_ExpressionMatrix[Nano_ExpressionMatrix$subtype=="Normal/Cancer" |Nano_ExpressionMatrix$subtype=="TCGA" | Nano_ExpressionMatrix$subtype=="TME" | Nano_ExpressionMatrix$subtype=="Negative" |Nano_ExpressionMatrix$subtype=="Positive" |Nano_ExpressionMatrix$subtype=="Housekeeping" ,]$Probe.Name
Nano_SampleInfo$SampleNames <- colnames(Nano_RawCounts)



##################################################################################################################################
##################################################################  Exploratory  data analysis – raw counts #####################
#***** Colors for each cartridges
Color_Batches <- c('purple','orange','darkred','blue','chartreuse',
                   'darkgoldenrod4','tan2','darkgreen','red3','darkmagenta',
                   'deeppink','violet','navy','red','dodgerblue')

#***** box plot of raw data - Endogenous genes only
RawCounts_log <- log2(Nano_RawCounts[1:118 , ]+1) # Excluding 7 housekeeping genes and Nanostring spike-ins
par(mar = c(6.5,6.5,2.3,0), mgp = c(3.7 , 1 , 0))
boxplot(RawCounts_log, las = 1, cex.axis = 2, ylab = '' , xlab = '', cex.lab = 4,
        xaxt = 'n', yaxt = 'n', main = 'Unnormalized counts', cex.main = 3.5,
        outline = FALSE, names = FALSE, frame = FALSE,
        whisklty = 3, whisklwd = 1.5, staplelty = 1, notch = TRUE, boxlwd = 2,
        staplelwd = 0 , boxcol = Color_Batches[factor(Nano_SampleInfo$Cartridges)],
        border = Color_Batches[factor(Nano_SampleInfo$cartridge)] , col='gray87')
box(lwd = 7, bty = 'l')
axis(1, cex.axis=1, at = c(1, seq(20,166,20)), cex.axis = 2.5, lwd.ticks = 4, mgp = c(3.5,1.6,0))
axis(2, at = c(0, seq(3,15,3)), mgp = c(3.5,.9,0), lwd.ticks = 4, las = 1, cex.axis=3)
mtext(expression(paste('Samples', '(', 'n'[samples], '=', '162', ')')), 1, line = 4.5, cex = 2.5)
mtext(expression(paste(Log[2],' (raw counts)')), 2, line = 3.5, cex = 2.7)


#***** RLE plot - Figure 1 A - Unormalized
par(mar = c(6.5,6.5,2.3,0))
boxplot(RawCounts_log - rowMedians(RawCounts_log),
        main = '', xlab = '', ylab = '', xaxt = 'n', yaxt = 'n', ylim = c(-4.1,4.1),
        outline = FALSE, names = FALSE, frame = FALSE, whisklty = 3, whisklwd = 1.5, staplelty = 1, notch = TRUE, boxlwd = 2,
        staplelwd = 0 , boxcol = Color_Batches[factor(Nano_SampleInfo$cartridge)],
        border = Color_Batches[factor(Nano_SampleInfo$cartridge)], col = 'gray87')
box(lwd = 7, bty = 'l')
title('Unnormalized counts', line = -2, cex.main = 3.5)
Median_RawData <- apply(RawCounts_log - rowMedians(RawCounts_log), 2, median)
points(c(1:ncol(RawCounts_log)), Median_RawData, col = Color_Batches[factor(Nano_SampleInfo$cartridge)], pch = 19, cex = 1.2)
axis(2, mgp = c(3.5, .9 ,0), lwd.ticks=6, las=1, cex.axis=3)
mtext('RLE', 2, line = 3.5, cex = 3.5)
abline(h = 0, col = 'black', lwd = 5, lty = 2)
par(lwd = 3)
legend(160, 4.1, legend = c(1,2,3,'.','.','.', 13,14,15),
       col = c(Color_Batches[1:3], rep('white', 3), Color_Batches[13:15]),
       pch = 19, bty = 'n', cex = 1.4)
text(x = 162, y = 4.2 ,labels  = 'Cartridges', cex = 1.5)
rm(Median_RawData)


#***** Average plot
### Average of Nanostring positive spike-ins controls
Mean_NegativeControlProbes <- apply(Nano_RawCounts[115:122, ], 2, mean)
### Average of Nanostring positive spike-ins controls
Mean_PositiveControlProbes <- apply(Nano_RawCounts[123:128, ], 2, mean)
### Average of housekeeping genes
Mean_HousekeepingGenes <- apply(Nano_RawCounts[108:114, ], 2, mean)
### Library size
LibrarySize <- colSums(Nano_RawCounts [ 1:128, ])

#### Average plots -  Supplementary Figure 2
par(mar = c(6,7,0,0))
plot(log2(LibrarySize), ylim = c(0,22), bty = 'l', typ = 'n', ylab = '', xlab = '', xaxt = 'n', yaxt = 'n')
axis(1, cex.axis = 1, at = c(1, seq(20,166,20)), cex.axis = 2, lwd.ticks = 4, mgp = c(3.5,1.4,0))
axis(2, cex.axis = 1, cex.axis = 2, lwd.ticks = 4, mgp = c(3.5,1,0), las = 1)
mtext(expression(paste(Log [2], ' (raw counts)')), 2, line = 3.5, cex = 3)
mtext(expression(paste('Samples', ' (', 'n'[samples], '=', '21', ')')), 1, line = 4.5, cex = 2.5)
X <- c(0,6,18,30,42,53,65,77,89,101,113,125,137,143,155,167)
GradiantColors <- paste0('gray', seq(90,20, by = -5))
for(i in 1:15) rect(X[i],-5, X[i+1], 22, col = GradiantColors[i], lty = 0 )
points(log2(LibrarySize), col = alpha('darkgoldenrod1', .8), pch = 15, cex = 1.8, lwd = 1.5)
lines(smooth.spline(c(1:length(LibrarySize)), log2(LibrarySize), df = 5), col = 'darkgoldenrod1', lwd = 4)
points(log2(Mean_HousekeepingGenes) + 3, cex = 2, col = alpha('red', .6), pch = 19)
lines(smooth.spline(c(1:length(LibrarySize)), log2(Mean_HousekeepingGenes) + 3, df = 5), col = 'red', lwd = 4)
points(log2(Mean_PositiveControlProbes) - 1, col = alpha('cyan2', .8), pch = 18, cex = 2.5)
lines(smooth.spline(c(1:length(LibrarySize)), log2(Mean_PositiveControlProbes) - 1, df = 5), col = 'cyan1', lwd = 4)
points(log2(Mean_NegativeControlProbes), col = alpha('green2', .6), pch = 17, cex = 1.8)
lines(smooth.spline(c(1:length(LibrarySize)), log2(Mean_NegativeControlProbes), df = 5), col = 'green2', lwd = 4)
box(lwd = 5, bty = 'l')
rm(X, GradiantColors, Mean_NegativeControlProbes,
   Mean_PositiveControlProbes, Mean_HousekeepingGenes,
   LibrarySize)


#***** Log ratio between all pairs of duplicated samples
DuplicatedSamples <- tuplicate(Nano_SampleInfo$Patient.barcodes, 2)
length(DuplicatedSamples) 

LogRatio_TechRep_RawCounts <- vector()
for(i in 1:1){
  index <- Nano_SampleInfo$Patient.barcodes == DuplicatedSamples[i]
  RepData <- RawCounts_log [ , index]
  LogRatio <- as.data.frame(RepData[ , 1] - RepData[ , 2] )
  colnames(LogRatio) <- 'LogRatio'
  LogRatio$Replicates <- rep( i , 118)
  LogRatio_TechRep_RawCounts <- rbind(LogRatio_TechRep_RawCounts , LogRatio)
  rm(i, index, RepData, LogRatio)
}
nrow(LogRatio_TechRep_RawCounts)/118 # 17
LogRatio_TechRep_RawCounts$Datasets <- 'Unnormalized'




##################################################################################################################################
############################################### RUV-III normalization - using technical replicates and control genes #############

#***** Creating replicate matrix
length(Nano_SampleInfo$Patient.barcodes) # 162
length(unique(Nano_SampleInfo$Patient.barcodes)) # 135

ReplicateMatrix <- ruv::replicate.matrix(Nano_SampleInfo$Patient.barcodes)
dim(ReplicateMatrix) # 162 133

### Making sure that every row has got only one number
par(mfrow = c(2,1))
barplot(colSums(ReplicateMatrix))
barplot(rowSums(ReplicateMatrix))
par(mfrow = c(1,1))


#***** Finding control genes
### Step 1: Using all genes as a set of negative control genes
# Performing RUVIII
dataRUV <- t(log2(Nano_RawCounts[1:118, ] + 1))
RUVcorrected <- ruv::RUVIII(Y = dataRUV, M = ReplicateMatrix, ctl = c(1:118))
RUVcorrected <- t(RUVcorrected)

### Step 2: Selecting the most stable genes from step 1
LowVarGenes <- apply(RUVcorrected, 1, var)
ControlGenes <- which(LowVarGenes < .5)
length(ControlGenes) # 15 genes


### Step3: Performing RUV-III using the ControlGenes set
RUVcorrected <- RUVIII(Y = dataRUV, M = ReplicateMatrix, ctl = ControlGenes, k = 7)
RUVcorrected <- t(RUVcorrected)
dim(RUVcorrected)
# We tried different numbers of k based on our positive controls####
all(colnames(RUVcorrected) == Nano_SampleInfo$SampleNames) ## TRUE


#***** RLE plots - Figure 1 A, RUV-III normalization
par(mar = c(6.5,6.5,2.3,0))
boxplot(RUVcorrected - rowMedians(RUVcorrected), main = '', xlab = '', ylab = '', xaxt = 'n', yaxt = 'n', ylim = c(-4.1,4.1),
        outline = FALSE, names = FALSE, frame = FALSE, whisklty = 3, whisklwd = 1.5, staplelty = 1, notch = TRUE, boxlwd = 2,
        staplelwd = 0 , boxcol = Color_Batches[factor(Nano_SampleInfo$cartridge)],
        border = Color_Batches[factor(Nano_SampleInfo$cartridge)], col = 'gray87')
box(lwd = 7, bty = 'l')
title('RUV-III normalized', line = -2, cex.main = 3.5)
Median_RUV <- apply(RUVcorrected - rowMedians(RUVcorrected), 2, median)
points(c(1:ncol(RUVcorrected)), Median_RUV, col = Color_Batches[factor(Nano_SampleInfo$cartridge)], pch = 19, cex = 1.2)
axis(1, cex.axis = 1, at = c(1, seq(20,166,20)), cex.axis = 2.5, lwd.ticks = 6,  mgp = c(3.5,1.6,0))
axis(2, mgp = c(3.5,.9,0), lwd.ticks = 6, las = 1, cex.axis = 3)
mtext(expression(paste('Samples','(', 'n'[samples], '=', '162', ')')),1 ,line = 5, cex = 3)
mtext('RLE', 2, line = 3.5, cex = 3.5)
abline(h = 0, col = 'black', lwd = 5, lty = 2)


#***** Correlation between ERCC1 and RRM1 in cancer samples
RUVIII_CancerData <- RUVcorrected[ , Nano_SampleInfo$Tissues=="cancer"]
dim(RUVIII_CancerData) ## 587 150
BioCo_RUV <- cor.test(unlist(t(RUVIII_CancerData['SMAD9' , ])) , unlist(t(RUVIII_CancerData[ 'JAK2' , ])), method = "spearman")[[4]]
par(mar = c(5,5,2,1))
plot (RUVIII_CancerData[ "SMAD9", ], RUVIII_CancerData [ "JAK2" , ],
      las = 1, pch = 21, col = "cyan", bg = 'blue', lwd = 1.2,
      main = "RUV-III normalized", bty = "l", cex.main = 2, mgp = c(3.2,.8,0),
      cex.axis = 1.7, cex.lab = 1.5, cex = 2.5, lwd.ticks = 3, ylab = "" ,
      xlab = expression(paste(italic(RRM1) , " (", log[2] , " normalized counts" , ")")))
mtext(expression(paste(italic(ERCC1) , " (", log[2] , " normalized counts" , ")")), 2, line = 3, cex = 1.5)
title(paste('(r = ', round(BioCo_RUV, digits = 2), ')'), line = -.5, cex = 1.4)
box(lwd = 6, bty = "l")


#***** Log DIFFERENCE between technical duplicated - per the paper
### Assessing the perfromance of RUV-III using 'leave out one duplicate'
DuplicatedSamples <- tuplicate(Nano_SampleInfo$Patient.barcodes, 2)
length(DuplicatedSamples) # 17
LogRatio_TechRep_RUVIII <- vector()
dataRUV <- t(log2(Nano_RawCounts[1:107, ] +1))

for(l in 1:length(DuplicatedSamples)){
  index <- Nano_SampleInfo$Patient.barcodes == DuplicatedSamples[l]
  info <- Nano_SampleInfo
  info$Patient.barcodes[index] <- c('Rep1', 'Rep2')
  X <- length(info$Patient.barcodes)
  Y <- length(unique(info$Patient.barcodes))
  
  ReplicateMatrix <- matrix(0, nrow = X, ncol = Y)
  row.names(ReplicateMatrix) <- info$Patient.barcodes
  colnames(ReplicateMatrix) <- unique(info$Patient.barcodes)
  for(i in 1:Y){
    n <- colnames(ReplicateMatrix)[i]
    sa <- which(row.names(ReplicateMatrix)==n)
    for(j in 1:length(sa)){
      ReplicateMatrix [sa[j] , i] <- 1
    }
  }
  RUVcorrected_Data <- ruv::RUVIII(dataRUV , ReplicateMatrix , ctl = ControlGenes, k = 2)
  RUVcorrected_Data <- t(RUVcorrected_Data)
  index <- which(index)
  LogRatio <- as.data.frame( (RUVcorrected_Data[ , index[1]] ) - (RUVcorrected_Data[ , index[2]]) )
  colnames(LogRatio) <- 'LogRatio'
  LogRatio$Replicates <- rep(l , 107)
  LogRatio_TechRep_RUVIII <- rbind(LogRatio_TechRep_RUVIII , LogRatio)
  rm(i, index, info, X, Y, LogRatio)
  
}
nrow(LogRatio_TechRep_RUVIII)/107
LogRatio_TechRep_RUVIII$Datasets <- 'RUV-III normalized'


#***** Technical Replicate Agreement plot for unnormalized, Nanostring Normalization and RUV-III (leave out one technical replicate)
### Figure 1 B
TRAallNormalizations <- rbind(LogRatio_TechRep_RawCounts, LogRatio_TechRep_RUVIII)
TRAallNormalizations$Replicates <- as.factor(TRAallNormalizations$Replicates)
TRAallNormalizations$Datasets <- as.factor(TRAallNormalizations$Datasets)
TRAallNormalizations$Datasets  <- factor(TRAallNormalizations$Datasets , levels = c('Unnormalized','RUV-III normalized'))
ggplot(data = TRAallNormalizations) +
  geom_boxplot(aes(y = LogRatio, x = Replicates, fill = Datasets, color=Datasets), outlier.size = .5,
               position = position_dodge(width = .7),
               width = 1, alpha = 0.8, lwd = .7) +
  ylab('Log ratio')+ylim(c(-10,10)) +
  scale_color_manual(values = c('lightblue', 'royalblue', 'navy')) +
  scale_fill_manual(values = c('lightblue', 'royalblue', 'navy')) +
  theme_classic() +
  geom_hline(yintercept = 0, lty = 2, lwd = .6, col = 'red')+
  theme(axis.title = element_text(size = 25),
        axis.text.x = element_text(size = 20),
        axis.text.y = element_text(size = 20),
        axis.line = element_line(size = 1.5),
        legend.title = element_text(size = 20, face = c('italic', 'bold')),
        legend.text = element_text(size = 20),
        legend.position = "top", legend.direction = "horizontal")


#***** Log RATIO between technical duplicated - the paper incorrectly called the log difference the ratio 
### Assessing the perfromance of RUV-III using 'leave out one duplicate'
DuplicatedSamples <- tuplicate(Nano_SampleInfo$Patient.barcodes, 2)
length(DuplicatedSamples) # 17
LogRatio_TechRep_RUVIII <- vector()
dataRUV <- t(log2(Nano_RawCounts[1:107, ] +1))

for(l in 1:length(DuplicatedSamples)){
  index <- Nano_SampleInfo$Patient.barcodes == DuplicatedSamples[l]
  info <- Nano_SampleInfo
  info$Patient.barcodes[index] <- c('Rep1', 'Rep2')
  X <- length(info$Patient.barcodes)
  Y <- length(unique(info$Patient.barcodes))
  
  ReplicateMatrix <- matrix(0, nrow = X, ncol = Y)
  row.names(ReplicateMatrix) <- info$Patient.barcodes
  colnames(ReplicateMatrix) <- unique(info$Patient.barcodes)
  for(i in 1:Y){
    n <- colnames(ReplicateMatrix)[i]
    sa <- which(row.names(ReplicateMatrix)==n)
    for(j in 1:length(sa)){
      ReplicateMatrix [sa[j] , i] <- 1
    }
  }
  RUVcorrected_Data <- ruv::RUVIII(dataRUV , ReplicateMatrix , ctl = ControlGenes, k = 2)
  RUVcorrected_Data <- t(RUVcorrected_Data)
  index <- which(index)
  LogRatio <- as.data.frame( (RUVcorrected_Data[ , index[1]] ) / (RUVcorrected_Data[ , index[2]]))
  colnames(LogRatio) <- 'LogRatio'
  LogRatio$Replicates <- rep(l , 107)
  LogRatio_TechRep_RUVIII <- rbind(LogRatio_TechRep_RUVIII , LogRatio)
  rm(i, index, info, X, Y, LogRatio)
  
}
nrow(LogRatio_TechRep_RUVIII)/107
LogRatio_TechRep_RUVIII$Datasets <- 'RUV-III normalized'


#***** Technical Replicate Agreement plot for unnormalized, Nanostring Normalization and RUV-III (leave out one technical replicate)
### Figure 1 B
TRAallNormalizations <- rbind(LogRatio_TechRep_RawCounts, LogRatio_TechRep_RUVIII)
TRAallNormalizations$Replicates <- as.factor(TRAallNormalizations$Replicates)
TRAallNormalizations$Datasets <- as.factor(TRAallNormalizations$Datasets)
TRAallNormalizations$Datasets  <- factor(TRAallNormalizations$Datasets , levels = c('Unnormalized','RUV-III normalized'))
ggplot(data = TRAallNormalizations) +
  geom_boxplot(aes(y = LogRatio, x = Replicates, fill = Datasets, color=Datasets), outlier.size = .5,
               position = position_dodge(width = .7),
               width = 1, alpha = 0.8, lwd = .7) +
  ylab('Log ratio')+ylim(c(-10,10)) +
  scale_color_manual(values = c('lightblue', 'royalblue', 'navy')) +
  scale_fill_manual(values = c('lightblue', 'royalblue', 'navy')) +
  theme_classic() +
  geom_hline(yintercept = 1, lty = 2, lwd = .6, col = 'red')+
  theme(axis.title = element_text(size = 25),
        axis.text.x = element_text(size = 20),
        axis.text.y = element_text(size = 20),
        axis.line = element_line(size = 1.5),
        legend.title = element_text(size = 20, face = c('italic', 'bold')),
        legend.text = element_text(size = 20),
        legend.position = "top", legend.direction = "horizontal")

############################################FINAL NORMALIZATION with 117 genes###################################################
length(Nano_SampleInfo$Patient.barcodes) # 162
length(unique(Nano_SampleInfo$Patient.barcodes)) # 135

ReplicateMatrix <- ruv::replicate.matrix(Nano_SampleInfo$Patient.barcodes)
dim(ReplicateMatrix) # 162 133
#***** Finding control genes
### Step 1: Using all genes as a set of negative control genes
# Performing RUVIII
dataRUV <- t(log2(Nano_RawCounts[1:118, ] +1))
RUVcorrected <- ruv::RUVIII(Y = dataRUV, M = ReplicateMatrix, ctl = c(1:118))
RUVcorrected <- t(RUVcorrected)

### Step 2: Selecting the most stable genes from step 1
LowVarGenes <- apply(RUVcorrected, 1, var)
ControlGenes <- which(LowVarGenes < .5)
length(ControlGenes) # 15 genes


### Step3: Performing RUV-III using the ControlGenes set
RUVcorrected <- RUVIII(Y = dataRUV, M = ReplicateMatrix, ctl = ControlGenes, k = 7)
RUVcorrected <- t(RUVcorrected)
dim(RUVcorrected)
# We tried different numbers of k based on our positive controls
all(colnames(RUVcorrected) == Nano_SampleInfo$SampleNames) ## TRUE

RUVcorrected_all_organoid = RUVcorrected
```

#Heatmap
```{r}
#normalized together ffpe
common_nanostring = RUVcorrected_all_organoid
pheatmap(common_nanostring)

common_nanostring = t(common_nanostring)
common_nanostring = as.data.frame(common_nanostring)

names = Nano_SampleInfo
names = dplyr::select(names, c("Patient.barcodes","SampleNames"))

common_nanostring = tibble::rownames_to_column(common_nanostring, "sample_id")


normcancer_organoid = merge(common_nanostring, names, by.x="sample_id", by.y="SampleNames")
normcancer_organoid = normcancer_organoid[,-1]
colnames(normcancer_organoid)[which(names(normcancer_organoid) == "Patient.barcodes")] <- "sample_id"


normcancer_organoid %>% group_by(sample_id) %>% summarise_all(mean) %>% data.frame() -> normcancer_organoid
normcancer_organoid = tibble::column_to_rownames(normcancer_organoid, "sample_id")
normalgenes <- Nano_ExpressionMatrix[Nano_ExpressionMatrix$subtype=="Normal/Cancer",]$Probe.Name
normcancer_organoid <- normcancer_organoid[, normalgenes]
pheatmap(normcancer_organoid)

```
#Model test

```{r}


set.seed(99)
target = as.matrix(normcancer_ffpe)
test = as.matrix(normcancer_organoid)
fsqn_nanostring = quantileNormalizeByFeature(test, target)


colramp = colorRampPalette(c(3,"white",2))(20)
plot(density(t(normcancer_ffpe)[,1]),col=colramp[1],lwd=1,ylim=c(0,.40))
for(i in 2:18){lines(density(t(normcancer_ffpe)[,i]),lwd=1,col=colramp[i])}


colramp = colorRampPalette(c(3,"white",2))(20)
plot(density(t(normcancer_organoid)[,1]),col=colramp[1],lwd=1,ylim=c(0,.40))
for(i in 2:18){lines(density(t(normcancer_organoid)[,i]),lwd=1,col=colramp[i])}


colramp = colorRampPalette(c(3,"white",2))(20)
plot(density(t(fsqn_nanostring)[,1]),col=colramp[1],lwd=1,ylim=c(0,.40))
for(i in 2:18){lines(density(t(fsqn_nanostring)[,i]),lwd=1,col=colramp[i])}


predict.model_ = predict(model, fsqn_nanostring, type="raw")
predict.model_prob = predict(model, fsqn_nanostring, type="prob")

```



#Final try with new model on ACRG

```{r}
edata = combined_edata

x= data.matrix(x_train[,-119])
y= x_train$source
y = as.factor(y)

#Make our test and train data
#x= data.matrix(normcancer_ffpe)
#y= pdata$source
#y = as.factor(y)

```

# glmNET LASSO - Optimal performance on individual classification (Grouped data assessment not shown)

```{r}
set.seed(99)
model = caret::train(x,y,'glmnet',trControl=trainControl(method='boot632',  number=500))
```


###//////ACRG only dist////////

#ACRG
```{r}
data_log_norm_ACRG <- subset(log_norm_ACRG, rownames(log_norm_ACRG) %in% as.matrix(commongenes))
data_log_norm_ACRG = t(data_log_norm_ACRG)

normal = as.data.frame(data_log_norm_ACRG)
normal$type = "Normal"
normal= tibble::rownames_to_column(normal, "patient_id")
normal = dplyr::select(normal, c("patient_id", "type"))

log_ACRG_cancer <- subset(log_ACRG, rownames(log_ACRG) %in% as.matrix(commongenes))
log_ACRG_cancer = t(log_ACRG_cancer)

cancer = as.data.frame(log_ACRG_cancer)
cancer$type = "Cancer"
cancer= tibble::rownames_to_column(cancer, "patient_id")
cancer = dplyr::select(cancer, c("patient_id", "type"))

type = rbind(normal,cancer)
```

#QN cancer and normal
```{r}

combo_dist= rbind(data_log_norm_ACRG,log_ACRG_cancer)
combo_dist = as.matrix(combo_dist)
combo_dist = t(combo_dist)

colramp = colorRampPalette(c(3,"white",2))(20)
plot(density(combo_dist[,1]),col=colramp[1],lwd=1,ylim=c(0,.40))
for(i in 2:400){lines(density(combo_dist[,i]),lwd=1,col=colramp[i])}

```
```{r}
#Quantile normalize
norm_combo_dist = normalize.quantiles(as.matrix(combo_dist))
```

```{r}
#Check normalize data plot
plot(density(norm_combo_dist[,1]),col=colramp[1],lwd=1,ylim=c(0,.40))
for(i in 2:400){lines(density(norm_combo_dist[,i]),lwd=1,col=colramp[i])}
```

```{r}
x = colnames(combo_dist)
colnames(norm_combo_dist) = x
y = row.names(combo_dist)
row.names(norm_combo_dist) = y
```

#Reduce to cancer genes only 
```{r}
library(readxl)
#Data sets - reduce to commongenes and transpose for FSQN
Nanostring_gene_set_list <- read_excel("~/Documents/PhD/Chapter 3 paper/Nanostring gene set list.xlsx", sheet = "Nanostring geneset")
Nanostring_gene_set_list = as.data.frame(Nanostring_gene_set_list)
TCGA = Nanostring_gene_set_list$TCGA
TME = Nanostring_gene_set_list$TME
Norm = Nanostring_gene_set_list$`Normal vs Cancer`
genelist = c(TCGA, TME,Norm)
genelist = na.omit(genelist)
genelist = as.matrix(genelist)
#ACRG
common_dist <- subset(norm_combo_dist, rownames(norm_combo_dist) %in% as.matrix(genelist))
common_dist = t(common_dist)

common_dist = as.data.frame(common_dist)
common_dist = tibble::rownames_to_column(common_dist, "patient_id")

common_dist = merge(common_dist,type, by="patient_id")
common_dist = common_dist[c(1,119, 2:118)]
combined_edata = tibble::column_to_rownames(common_dist, "patient_id")

#cancer_sample = dplyr::select(as.data.frame(cancer_edata), "type")
#cancer_sample = tibble::rownames_to_column(cancer_sample, "patient_id")


#normal_sample = dplyr::select(normal_edata, "type")
#normal_sample = tibble::rownames_to_column(normal_sample, "patient_id")

#samples_assign = rbind(cancer_sample,normal_sample)

#combined_edata = merge(samples_assign,common_dist, by="patient_id")

#combined_edata = tibble::column_to_rownames(combined_edata, "patient_id")
```

#Establish nested CV

```{r}
combined_edata = as.data.frame(combined_edata)
#Create 80/20% data split at random

#Convert numeric columns to numeric
combined_edata[,2:ncol(combined_edata)] = lapply(2:ncol(combined_edata),function(x) as.numeric(combined_edata[[x]]))
```
```{r}
set.seed(99)
trainRowNumbers = createDataPartition(combined_edata$type, p=0.8,list=FALSE,times = 5)
trainRowNumbers = as.data.frame(trainRowNumbers)
```

#/////CV fold 1 for lasso features/////

```{r}
trainData1 = combined_edata[trainRowNumbers$Resample1,]
testData1 = combined_edata[-trainRowNumbers$Resample1,]
```
```{r}
#Make our test and train data
x=data.matrix(trainData1[, 2:118])
y= trainData1$type
y = as.factor(y)
x.test= data.matrix(testData1[, 2:118])
y.test = testData1$type
y.test = as.factor(y.test)
```

# glmNET LASSO - Optimal performance on individual classification (Grouped data assessment not shown)

```{r}
set.seed(99)
lasso.10fold = cv.glmnet(x,y,family="multinomial", nfolds=10)
lasso.10fold.model1 = lasso.10fold
predict.lasso.10fold = predict(lasso.10fold, x.test, type="class")
table.lasso.10fold = table(predict.lasso.10fold, y.test)
full.lasso1 = confusionMatrix(table.lasso.10fold, mode = "everything")
full.lasso1
```
```{r}
#Brier Score for Lasso
brier.lasso = predict(lasso.10fold, x.test, type="response")
brier.lasso = (brier.lasso)/rowSums(brier.lasso)
brier.lasso.full1 = multiclass.Brier(brier.lasso,y.test)
brier.lasso.full1
```

#Extract features
```{r}
coef.lasso.10fold = coef(lasso.10fold, s="lambda.min")
```
```{r}
featuresextracted.lasso = as.data.frame(x) %>% dplyr::select(coef.lasso.10fold[["Normal"]]@i,coef.lasso.10fold[["Cancer"]]@i)

x.lasso = as.matrix(featuresextracted.lasso)
x.lassoTCGA1 = x.lasso

featuresextracted.lasso.test = as.data.frame(x.test) %>% dplyr::select(coef.lasso.10fold[["Normal"]]@i,coef.lasso.10fold[["Cancer"]]@i)

x.lasso.test = as.matrix(featuresextracted.lasso.test)
x.lasso.testTCGA1 = x.lasso.test
```


#Lasso with lasso features
```{r}
set.seed(99)
lasso.lasso = caret::train(x.lasso,y,'glmnet',trControl=trainControl(method='repeatedcv',number=5, repeats = 3))
lasso.lasso.model1 = lasso.lasso
predict.lasso.lasso = predict(lasso.lasso,x.lasso.test)
table.lasso.lasso = table(predict.lasso.lasso,y.test)
lasso.lasso1 = confusionMatrix(table.lasso.lasso, mode = "everything")
lasso.lasso1
```
```{r}
#Brier Score for Lasso
brier.lasso.lasso = predict(lasso.lasso, x.lasso.test, type="prob")
brier.lasso.lasso = (brier.lasso.lasso)/rowSums(brier.lasso.lasso)
brier.lasso.lasso1 = multiclass.Brier(brier.lasso.lasso,y.test)
brier.lasso.lasso1
```


#ACRG model test

```{r}
normcancer_ffpe_reduced = as.data.frame(normcancer_ffpe) %>% dplyr::select(colnames(x.lasso))

set.seed(99)
target = as.matrix(x.lasso)
test = as.matrix(normcancer_ffpe_reduced)
fsqn_nanostring = quantileNormalizeByFeature(test, target)

###NEED TO REDUCE THE NUMBER OF GENES AND THEN NEEDS TO MAKE SURE THEY ARE IN THE RIGHT ORDER. 

colramp = colorRampPalette(c(3,"white",2))(20)
plot(density(t(x.lasso)[,1]),col=colramp[1],lwd=1,ylim=c(0,.40))
for(i in 2:18){lines(density(t(x.lasso)[,i]),lwd=1,col=colramp[i])}


colramp = colorRampPalette(c(3,"white",2))(20)
plot(density(t(normcancer_ffpe_reduced)[,1]),col=colramp[1],lwd=1,ylim=c(0,.40))
for(i in 2:18){lines(density(t(normcancer_ffpe_reduced)[,i]),lwd=1,col=colramp[i])}


colramp = colorRampPalette(c(3,"white",2))(20)
plot(density(t(fsqn_nanostring)[,1]),col=colramp[1],lwd=1,ylim=c(0,.40))
for(i in 2:18){lines(density(t(fsqn_nanostring)[,i]),lwd=1,col=colramp[i])}

selected_genes =  colnames(x.lasso)
fsqn_nanostring <- fsqn_nanostring[selected_genes,]


predict.model_acrg = predict(lasso.lasso.model1, fsqn_nanostring, type="raw")
predict.model_prob_acrg = predict(lasso.lasso.model1, fsqn_nanostring, type="prob")

cheese = normcancer_ffpe_reduced
cheese$type = predict.model_acrg
cheese$prob = predict.model_prob_acrg
cheese = tibble::rownames_to_column(cheese, "sample")
cheese$test = ifelse(grepl("67C", cheese$sample, ignore.case = T), "Normal", ifelse(grepl("N", cheese$sample, ignore.case = T), "Normal","Cancer"))
cheese = cheese[,-c(2:22)]
table(cheese$test, cheese$type)
confusionMatrix(table(cheese$test, cheese$type))

plot(as.factor(cheese$test),cheese$prob$Cancer)
kruskal.test(cheese$prob$Cancer,as.factor(cheese$test))
```
#Test with organoid

```{r}


#Reduce to final genes in proper order. 
normcancer_organoid_reduced = as.data.frame(normcancer_organoid) %>% dplyr::select(colnames(x.lasso))


#Remember to match the training to x.lasso
set.seed(99)
target = as.matrix(x.lasso)
test = as.matrix(normcancer_organoid_reduced)
fsqn_nanostring_organoid = quantileNormalizeByFeature(test, target)


colramp = colorRampPalette(c(3,"white",2))(20)
plot(density(t(x.lasso)[,1]),col=colramp[1],lwd=1,ylim=c(0,.40))
for(i in 2:18){lines(density(t(x.lasso)[,i]),lwd=1,col=colramp[i])}


colramp = colorRampPalette(c(3,"white",2))(20)
plot(density(t(normcancer_organoid)[,1]),col=colramp[1],lwd=1,ylim=c(0,.40))
for(i in 2:18){lines(density(t(normcancer_organoid)[,i]),lwd=1,col=colramp[i])}


colramp = colorRampPalette(c(3,"white",2))(20)
plot(density(t(fsqn_nanostring_organoid)[,1]),col=colramp[1],lwd=1,ylim=c(0,.40))
for(i in 2:18){lines(density(t(fsqn_nanostring_organoid)[,i]),lwd=1,col=colramp[i])}


predict.model_acrg_org = predict(lasso.lasso.model1, fsqn_nanostring_organoid, type="raw")
predict.model_prob_acrg_org = predict(lasso.lasso.model1, fsqn_nanostring_organoid, type="prob")

cheese = normcancer_organoid_reduced
cheese$type = predict.model_acrg_org
cheese$prob = predict.model_prob_acrg_org
cheese = tibble::rownames_to_column(cheese, "sample")
cheese$test = ifelse(grepl("67C-O", cheese$sample, ignore.case = T), "Normal", ifelse(grepl("N", cheese$sample, ignore.case = T), "Normal","Cancer"))
cheese = cheese[ ,-c(2:22)]
table(cheese$type,cheese$test)
confusionMatrix(table(cheese$type,cheese$test))

plot(as.factor(cheese$test),cheese$prob$Cancer)
kruskal.test(cheese$prob$Cancer,as.factor(cheese$test))
```




